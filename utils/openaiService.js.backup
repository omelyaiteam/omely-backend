// SERVICE CENTRALIS√â OPENAI - GPT-4O MINI POUR OMELY
import OpenAI from 'openai';

// Configuration OpenAI
const OPENAI_CONFIG = {
  apiKey: process.env.OPENAI_API_KEY || 'your-openai-api-key-here',
  model: 'gpt-4o-mini', // Mod√®le sp√©cifi√© par l'utilisateur
  rateLimit: {
    requestsPerMinute: 60, // OpenAI a des limites plus g√©n√©reuses
    maxConcurrentRequests: 8,
    retryAttempts: 3,
    baseDelay: 500,  // OPTIMIS√â: R√©duit de 1000ms √† 500ms
    maxDelay: 5000,  // OPTIMIS√â: R√©duit de 10000ms √† 5000ms
    backoffMultiplier: 1.5  // OPTIMIS√â: R√©duit de 2 √† 1.5
  }
};

// Instance OpenAI
const openai = new OpenAI({
  apiKey: OPENAI_CONFIG.apiKey,
});

// Queue de gestion des requ√™tes OpenAI
class OpenAIRequestQueue {
  constructor(config) {
    this.config = config;
    this.requestTimes = [];
    this.activeRequests = 0;
    this.queue = [];
    this.processing = false;
  }

  async addRequest(requestFn, priority = 'normal') {
    return new Promise((resolve, reject) => {
      const request = { 
        requestFn, 
        resolve, 
        reject, 
        priority,
        timestamp: Date.now()
      };
      
      // Ins√©rer selon la priorit√©
      if (priority === 'high') {
        this.queue.unshift(request);
      } else {
        this.queue.push(request);
      }
      
      this.processQueue();
    });
  }

  async processQueue() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;
    
    while (this.queue.length > 0 && this.activeRequests < this.config.maxConcurrentRequests) {
      const { requestFn, resolve, reject } = this.queue.shift();
      this.activeRequests++;
      
      this.executeRequest(requestFn, resolve, reject);
      
      // Attendre avant la prochaine requ√™te
      await this.waitForRateLimit();
    }
    
    this.processing = false;
  }

  async executeRequest(requestFn, resolve, reject) {
    try {
      const result = await this.retryRequest(requestFn);
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.activeRequests--;
      // Continuer le traitement de la queue
      setTimeout(() => this.processQueue(), 100);
    }
  }

  async retryRequest(requestFn, attempt = 1) {
    try {
      this.recordRequest();
      const result = await requestFn();
      return result;
    } catch (error) {
      if (attempt <= this.config.retryAttempts) {
        // G√©rer les diff√©rents types d'erreurs OpenAI
        const shouldRetry = this.shouldRetryError(error);
        
        if (shouldRetry) {
          const delay = this.calculateRetryDelay(error, attempt);
          
          console.log(`‚ö†Ô∏è Erreur OpenAI: ${error.message} (tentative ${attempt}/${this.config.retryAttempts}). Attente ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          
          return this.retryRequest(requestFn, attempt + 1);
        }
      }
      throw error;
    }
  }

  shouldRetryError(error) {
    // Retry sur les erreurs temporaires
    if (error.status === 429) return true; // Rate limit
    if (error.status === 503) return true; // Service unavailable
    if (error.status === 502) return true; // Bad gateway
    if (error.status >= 500) return true; // Server errors
    if (error.code === 'ECONNRESET') return true; // Connection reset
    if (error.code === 'ETIMEDOUT') return true; // Timeout
    
    return false;
  }

  calculateRetryDelay(error, attempt) {
    const { baseDelay, maxDelay, backoffMultiplier } = this.config;
    
    // D√©lai sp√©cifique selon le type d'erreur
    let delay = baseDelay;
    
    if (error.status === 429) {
      delay = 3000; // 3 secondes pour rate limit
    } else if (error.status >= 500) {
      delay = 2000; // 2 secondes pour erreurs serveur
    }
    
    // Appliquer le backoff exponentiel
    delay = delay * Math.pow(backoffMultiplier, attempt - 1);
    
    // Limiter au maximum
    return Math.min(delay, maxDelay);
  }

  recordRequest() {
    const now = Date.now();
    this.requestTimes.push(now);
    
    // Nettoyer les requ√™tes anciennes (plus d'une minute)
    this.requestTimes = this.requestTimes.filter(time => now - time < 60000);
  }

  async waitForRateLimit() {
    const now = Date.now();
    const recentRequests = this.requestTimes.filter(time => now - time < 60000);
    
    // V√©rifier si on d√©passe le rate limit
    if (recentRequests.length >= this.config.requestsPerMinute) {
      const oldestRequest = Math.min(...recentRequests);
      const waitTime = 60000 - (now - oldestRequest) + 500; // +500ms de s√©curit√©
      
      if (waitTime > 0) {
        console.log(`‚è≥ Rate limit OpenAI: attente ${waitTime}ms...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    // D√©lai minimum entre requ√™tes ULTRA-COURT
    await new Promise(resolve => setTimeout(resolve, 100));  // OPTIMIS√â: R√©duit de 200ms √† 100ms
  }

  // M√©thodes utilitaires
  getQueueStatus() {
    return {
      queueLength: this.queue.length,
      activeRequests: this.activeRequests,
      recentRequests: this.requestTimes.filter(time => Date.now() - time < 60000).length
    };
  }

  clearQueue() {
    this.queue = [];
    console.log('üîÑ Queue OpenAI vid√©e');
  }
}

// Instance globale de la queue
const openaiQueue = new OpenAIRequestQueue(OPENAI_CONFIG.rateLimit);

// FONCTIONS PRINCIPALES D'API

// Chat Completion avec queue ULTRA-RAPIDE
export async function createChatCompletion(messages, options = {}) {
  const defaultOptions = {
    model: OPENAI_CONFIG.model,
    temperature: 0.3,  // OPTIMIS√â: R√©duit pour rapidit√©
    max_tokens: 1500,
    top_p: 0.8,        // OPTIMIS√â: L√©g√®rement r√©duit pour focus
    frequency_penalty: 0,
    presence_penalty: 0,
    // AJOUT: Param√®tres de rapidit√©
    stream: false      // Pas de streaming pour rapidit√©
  };

  // Filtrer les options personnalis√©es qui ne sont pas des param√®tres OpenAI
  const { bookTitle, ...openaiOptions } = options;
  const finalOptions = { ...defaultOptions, ...openaiOptions };

  return openaiQueue.addRequest(async () => {
    try {
      console.log(`üîÑ Envoi requ√™te OpenAI: ${messages.length} messages`);

      const response = await openai.chat.completions.create({
        ...finalOptions,
        messages: messages
      });

      if (!response.choices || response.choices.length === 0) {
        throw new Error('R√©ponse vide de OpenAI');
      }

      const content = response.choices[0].message.content;
      console.log(`‚úÖ R√©ponse OpenAI re√ßue: ${content.length} caract√®res`);

      return content;
    } catch (error) {
      console.error('‚ùå Erreur OpenAI Chat:', error);

      // Gestion sp√©cifique des erreurs OpenAI
      if (error.status === 401) {
        console.error('üîë Erreur d\'authentification - v√©rifier OPENAI_API_KEY');
      } else if (error.status === 429) {
        console.error('‚è≥ Rate limit d√©pass√© - attendre avant retry');
      } else if (error.status === 500) {
        console.error('üîß Erreur serveur OpenAI - retry automatique');
      } else if (error.code === 'ENOTFOUND') {
        console.error('üåê Probl√®me de connexion r√©seau');
      }

      throw new Error(`Erreur OpenAI: ${error.message}`);
    }
  });
}

// Summarization de texte avec chunking intelligent
export async function summarizeText(text, type = 'general', options = {}) {
  try {
    // V√©rifications de s√©curit√©
    if (!text || typeof text !== 'string') {
      throw new Error('Texte invalide ou vide fourni √† summarizeText');
    }

    if (text.trim().length === 0) {
      throw new Error('Texte vide apr√®s nettoyage');
    }

    console.log(`‚ö° D√©marrage summarization OpenAI (${type})...`);
    console.log(`üìä Texte √† traiter: ${text.length} caract√®res`);
    console.log(`üéØ Type: ${type}, Options: ${JSON.stringify(options)}`);

    // Gestion des gros documents avec syst√®me de chunks
    const maxChunkSize = 15000; // Plus petit pour GPT-4o mini
    if (type === 'book') {
      console.log(`üìö Mode livre d√©tect√© - For√ßage pipeline par chunks`);
      // Toujours utiliser le pipeline par chunks pour les livres pour garantir l'exhaustivit√©
      return await summarizeTextWithChunks(text, type, options);
    }
    if (text.length > maxChunkSize) {
      console.log(`üìö Document volumineux (${text.length} caract√®res) - Traitement par chunks`);
      return await summarizeTextWithChunks(text, type, options);
    }
    
        const bookTitle = options.bookTitle || 'Livre';
    console.log(`üìñ Titre du livre: ${bookTitle}`);

    const systemPrompt = getSystemPromptForType(type, bookTitle);
    const userPrompt = `Texte √† analyser :\n\n${text}`;

    console.log(`üìù Longueur prompt syst√®me: ${systemPrompt.length} caract√®res`);
    console.log(`üìù Longueur prompt utilisateur: ${userPrompt.length} caract√®res`);

    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ];

    console.log(`ü§ñ Envoi requ√™te OpenAI...`);

    const isBook = type === 'book';
    const summary = await createChatCompletion(messages, {
      max_tokens: isBook ? 12000 : 2000,
      temperature: isBook ? 0.05 : 0.1,
      ...options
    });

    console.log(`‚úÖ Summarization OpenAI termin√©e (${summary.length} caract√®res)`);
    return summary;
    
  } catch (error) {
    console.error('‚ùå Erreur summarization OpenAI:', error);
    throw new Error(`√âchec de la summarization: ${error.message}`);
  }
}

// Summarization avec chunks PARALL√âLIS√âS pour vitesse maximale
async function summarizeTextWithChunks(text, type, options = {}) {
  try {
    console.log(`üîÑ D√©marrage traitement par chunks...`);
    console.log(`üìä Texte original: ${text.length} caract√®res`);

    // V√©rifications de s√©curit√© pour les chunks
    if (!text || typeof text !== 'string') {
      throw new Error('Texte invalide fourni √† summarizeTextWithChunks');
    }

    if (text.trim().length === 0) {
      throw new Error('Texte vide apr√®s nettoyage dans summarizeTextWithChunks');
    }

    const chunks = splitTextIntoAdaptiveChunks(text, { maxChunks: 40, preferredChunkSize: 18000, minChunkSize: 12000 });
    console.log(`‚ö° Document d√©coup√© en ${chunks.length} chunks (adaptatif par chapitres) - Traitement PARALL√àLE`);

    if (chunks.length === 0) {
      throw new Error('Aucun chunk g√©n√©r√© - texte trop court ou probl√®me de d√©coupage');
    }

    const startTime = Date.now();
    const bookTitle = options.bookTitle || 'Livre';
    console.log(`üìñ Titre du livre: ${bookTitle}`);

    // TRAITEMENT PARALL√àLE DE TOUS LES CHUNKS üöÄ
    console.log(`üöÄ Lancement du traitement parall√®le de ${chunks.length} chunks...`);
    
    const chunkPromises = chunks.map(async (chunk, i) => {
      const chunkPrompt = getEnhancedChunkPromptForType(type, i + 1, chunks.length, bookTitle);

      const messages = [
        { role: 'system', content: chunkPrompt },
        { role: 'user', content: `CHUNK ${i + 1}/${chunks.length} - EXTRACTION EXHAUSTIVE REQUISE:\n\n${chunk}` }
      ];
      
      try {
        console.log(`‚ö° D√©marrage chunk ${i + 1}/${chunks.length}...`);
        const chunkSummary = await createChatCompletion(messages, {
          max_tokens: 12000, // Maximum de tokens par chunk pour extraction ultra-exhaustive
          temperature: 0.03, // Tr√®s pr√©cis pour extraction factuelle
          ...options
        });
        console.log(`‚úÖ Chunk ${i + 1}/${chunks.length} termin√©`);
        return {
          index: i + 1,
          content: chunkSummary,
          success: true
        };
      } catch (error) {
        console.error(`‚ùå Erreur chunk ${i + 1}:`, error.message);
        return {
          index: i + 1,
          content: `Erreur traitement chunk ${i + 1}: ${error.message}`,
          success: false
        };
      }
    });
    
    // Attendre TOUS les chunks en parall√®le
    const chunkResults = await Promise.all(chunkPromises);
    const processingTime = Date.now() - startTime;
    
    console.log(`‚ö° PARALL√âLISATION TERMIN√âE en ${processingTime}ms`);
    console.log(`üìä R√©sultats: ${chunkResults.filter(r => r.success).length}/${chunks.length} chunks r√©ussis`);
    
    // Extraire les contenus r√©ussis
    const successfulChunks = chunkResults
      .filter(result => result.success)
      .sort((a, b) => a.index - b.index)
      .map(result => result.content);
    
    if (successfulChunks.length === 0) {
      throw new Error('Aucun chunk trait√© avec succ√®s');
    }
    
    // Combiner avec prompt ultra-d√©taill√©
    console.log(`üîÑ Combinaison FINALE de ${successfulChunks.length} chunks...`);
    const combinePrompt = getUltraDetailedCombinePrompt(type, successfulChunks.length, bookTitle);
    
    const combineMessages = [
      { role: 'system', content: combinePrompt },
      { role: 'user', content: `MISSION CRITIQUE: Combiner ces ${successfulChunks.length} extractions en un r√©sum√© ULTRA-COMPLET qui capture 100% de la valeur:\n\n${successfulChunks.map((summary, i) => `‚ïê‚ïê‚ïê SECTION ${i + 1} ‚ïê‚ïê‚ïê\n${summary}\n`).join('\n')}` }
    ];
    
    let finalSummary = await createChatCompletion(combineMessages, {
      max_tokens: 16384, // Limite maximale support√©e par GPT-4o mini
      temperature: 0.05, // Tr√®s pr√©cis pour combinaison exhaustive
      ...options
    });

    // PASS AUDIT DE COMPL√âTUDE: v√©rifier qu'aucune cat√©gorie n'est incompl√®te; si oui, demander un append cibl√©
    try {
      const auditMessages = [
        { role: 'system', content: 'Tu es un v√©rificateur d\'exhaustivit√©. Ne r√©√©cris pas; r√©ponds en JSON compact.' },
        { role: 'user', content: `Analyse le r√©sum√© ci-dessous et retourne un JSON {missing: {principes:[], differences:[], citations:[], histoires:[], exercices:[], stats:[]}} listant les √©l√©ments manquants s'il y en a.\n\nR√©sum√©:\n${finalSummary}` }
      ];
      const audit = await createChatCompletion(auditMessages, { max_tokens: 400, temperature: 0.0 });
      let missing;
      try { missing = JSON.parse(audit).missing; } catch (_) { missing = null; }
      const hasMissing = missing && Object.values(missing).some(arr => Array.isArray(arr) && arr.length > 0);
      if (hasMissing) {
        // Troncature prudente des sources pour √©viter un contexte trop gros
        let sources = successfulChunks.join('\n\n‚ïê‚ïê‚ïê‚ïê SOURCE CHUNK ‚ïê‚ïê‚ïê‚ïê\n\n');
        if (sources.length > 120000) {
          sources = sources.substring(0, 120000);
        }
        const appendMessages = [
          { role: 'system', content: 'Compl√®te UNIQUEMENT avec des listes sous les sections ad√©quates. Pas de r√©p√©tition. Titres en gras uniquement. Utilise UNIQUEMENT les √©l√©ments pr√©sents dans les sources fournies. N\'invente rien.' },
          { role: 'user', content: `Ajoute au r√©sum√© ci-dessous les √©l√©ments manquants en respectant strictement la structure.\n\n√âl√©ments manquants (JSON):\n${JSON.stringify(missing)}\n\nR√©sum√© actuel:\n${finalSummary}\n\nSOURCES (extractions des chunks):\n${sources}` }
        ];
        const appendix = await createChatCompletion(appendMessages, { max_tokens: 2000, temperature: 0.05 });
        finalSummary = `${finalSummary}\n\n${appendix}`;
      }
    } catch (auditErr) {
      console.warn('‚ö†Ô∏è Audit de compl√©tude ignor√©:', auditErr.message);
    }

    // AUDIT DE DENSIT√â: v√©rifier ratio longueur finale vs texte original
    try {
      const originalWordCount = text.trim().split(/\s+/).length;
      const finalWordCount = (finalSummary || '').trim().split(/\s+/).length;
      const densityRatio = finalWordCount / originalWordCount;
      
      console.log(`üìä Audit densit√©: ${finalWordCount} mots r√©sum√© / ${originalWordCount} mots original = ${(densityRatio * 100).toFixed(1)}%`);
      
      // Si ratio < 15% OU trop court, d√©clencher extraction suppl√©mentaire automatique
      if (densityRatio < 0.15 || finalWordCount < 3000) {
        let sources = successfulChunks.join('\n\n‚ïê‚ïê‚ïê‚ïê SOURCE CHUNK ‚ïê‚ïê‚ïê‚ïê\n\n');
        if (sources.length > 120000) {
          sources = sources.substring(0, 120000);
        }
        const expandMessages = [
          { role: 'system', content: '√âtends les sections existantes en ajoutant des √©l√©ments manquants des sources. √âvite la duplication compl√®te mais ajoute du contenu substantiel. N\'invente rien. Titres en gras uniquement.' },
          { role: 'user', content: `Le r√©sum√© ci-dessous est trop court. AJOUTE du contenu substantiel dans chaque section en te basant sur les SOURCES (plus de principes, diff√©rences, citations, histoires, exercices, stats). Ne r√©√©cris pas l\'existant, ajoute en dessous.\n\nR√©sum√© actuel:\n${finalSummary}\n\nSOURCES (extractions des chunks):\n${sources}` }
        ];
        const expansion = await createChatCompletion(expandMessages, { max_tokens: 4000, temperature: 0.04 });
        
        // V√©rifier que l'expansion n'est pas une duplication compl√®te
        const expansionWords = expansion.trim().split(/\s+/).length;
        const existingWords = finalSummary.trim().split(/\s+/).length;
        
        // Seuil plus permissif : rejeter seulement si c'est vraiment une duplication compl√®te
        if (expansionWords > existingWords * 1.2) {
          console.log('‚ö†Ô∏è Extension d√©tect√©e comme duplication potentielle, ignor√©e');
        } else {
          finalSummary = `${finalSummary}\n\n${expansion}`;
        }
      }
    } catch (expandErr) {
      console.warn('‚ö†Ô∏è Extension de longueur ignor√©e:', expandErr.message);
    }
    
    const totalTime = Date.now() - startTime;
    console.log(`üéâ TRAITEMENT ULTRA-RAPIDE TERMIN√â en ${totalTime}ms (${chunks.length} chunks parall√®les)`);
    
    return finalSummary;
    
  } catch (error) {
    console.error('‚ùå Erreur summarization parall√®le:', error);
    throw error;
  }
}

// Fonction de d√©coupage adaptatif (chapitres/sections) avec limite de chunks
function splitTextIntoAdaptiveChunks(text, {
  maxChunks = 40,
  preferredChunkSize = 18000,
  minChunkSize = 12000
} = {}) {
  // 1) D√©tecter chapitres/sections avec priorit√© au contenu principal
  const lines = text.split(/\n/);
  const sectionIndices = [];
  // Regex √©tendue pour d√©tecter plus de structures de chapitres/sections
  const sectionTitleRegex = /^(?:\s*(?:chapitre|chapter|partie|part|section|principe|r√®gle|loi|fichier|dossier)\b\s*[:#.-]?\s*|\s*(?:[IVXLC]+|\d+)\s*[).:-]\s+|^\s*[A-Z][A-Z\s]{10,}$)/i;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    // Prioriser les sections de contenu principal (√©viter intro/conclusion trop courtes)
    if (line.length > 5 && line.length < 200 && sectionTitleRegex.test(line)) {
      // √âviter les lignes qui semblent √™tre des annexes/r√©f√©rences
      if (!line.toLowerCase().includes('bibliographie') && 
          !line.toLowerCase().includes('r√©f√©rence') && 
          !line.toLowerCase().includes('annexe') &&
          !line.toLowerCase().includes('index')) {
        sectionIndices.push(i);
      }
    }
  }

  // Toujours inclure le d√©but si vide et la fin
  if (sectionIndices.length === 0) {
    sectionIndices.push(0);
  } else if (sectionIndices[0] !== 0) {
    sectionIndices.unshift(0);
  }
  sectionIndices.push(lines.length);

  // 2) Construire des sections par chapitres
  const sections = [];
  for (let s = 0; s < sectionIndices.length - 1; s++) {
    const start = sectionIndices[s];
    const end = sectionIndices[s + 1];
    const slice = lines.slice(start, end).join('\n').trim();
    if (slice) sections.push(slice);
  }

  // 3) Fusionner les petites sections et d√©couper les tr√®s grandes pour viser maxChunks
  // Calculer une taille cible selon le nombre de sections
  const roughTotal = text.length;
  const idealChunkSize = Math.max(minChunkSize, Math.min(preferredChunkSize, Math.ceil(roughTotal / Math.max(1, Math.min(maxChunks, sections.length)))));

  const chunks = [];
  for (const section of sections) {
    if (section.length <= idealChunkSize * 1.2) {
      chunks.push(section);
      continue;
    }

    // D√©coupage interne par paragraphes
    const paragraphs = section.split(/\n\s*\n/);
    let current = '';
    for (const p of paragraphs) {
      if ((current + (current ? '\n\n' : '') + p).length <= idealChunkSize) {
        current += (current ? '\n\n' : '') + p;
      } else if (p.length <= idealChunkSize * 0.75) {
        if (current) chunks.push(current);
        current = p;
      } else {
        // Paragraphe trop long: d√©couper par phrases
        const sentences = p.split(/(?<=[.!?])\s+/);
        for (const snt of sentences) {
          if ((current + (current ? ' ' : '') + snt).length <= idealChunkSize) {
            current += (current ? ' ' : '') + snt;
          } else {
            if (current) chunks.push(current);
            current = snt;
          }
        }
      }
    }
    if (current) chunks.push(current);
  }

  // 4) Si trop de chunks, fusionner adjacents jusqu'√† maxChunks
  while (chunks.length > maxChunks) {
    let merged = false;
    for (let i = 0; i < chunks.length - 1; i++) {
      const combinedLen = chunks[i].length + chunks[i + 1].length + 2;
      if (combinedLen <= preferredChunkSize * 1.5) {
        chunks.splice(i, 2, chunks[i] + '\n\n' + chunks[i + 1]);
        merged = true;
        break;
      }
    }
    if (!merged) break;
  }

  return chunks;
}

// Prompts syst√®me selon le type de contenu
function getSystemPromptForType(type, bookTitle = 'Livre') {
  const basePrompt = `Vous √™tes un EXTRACTEUR EXPERT sp√©cialis√© dans les livres d'enrichissement. Votre mission : cr√©er des r√©sum√©s COMPLETS et PARFAITEMENT LISIBLES.

üéØ VOTRE MISSION EN 2 √âTAPES:

**√âTAPE 1 - EXTRACTION EXHAUSTIVE:**
Lisez TOUT le texte et identifiez CHAQUE:
- Principe d'enrichissement (LOI, R√àGLE, PRINCIPE, CONCEPT)
- Diff√©rence comportementale (riches vs pauvres)
- Exercice pratique ou technique
- Citation importante
- Histoire ou anecdote

**√âTAPE 2 - PR√âSENTATION CLAIRE:**
Organisez TOUT dans un format fluide et engageant qui se lit facilement.

üö® R√àGLES ABSOLUES:

1. **EXHAUSTIVIT√â**: Ne manquez AUCUN principe mentionn√© dans le texte
2. **CLART√â**: Format lisible, bien structur√©, sections logiques
3. **ENGAGEMENT**: Style narratif captivant, pas de liste s√®che
4. **COMPL√âTUDE**: Minimum 3000 mots pour garantir la profondeur

üìñ M√âTHODE INFAILLIBLE:
1. Parcourez le texte phrase par phrase
2. Notez chaque principe/r√®gle/loi mentionn√©(e)
3. Extrayez TOUS les √©l√©ments trouv√©s
4. Organisez en r√©cit fluide et inspirant
5. V√©rifiez que RIEN n'est omis

‚ö†Ô∏è CRIT√àRE DE R√âUSSITE: L'utilisateur doit obtenir la valeur COMPL√àTE du livre dans un format qu'il a envie de lire jusqu'au bout.`;

  switch (type) {
    case 'book':
      return `${basePrompt}

MISSION ULTRA-CRITIQUE LIVRES:
- Extraire absolument TOUT: principes, cadres, m√©thodes, histoires, anecdotes, citations exactes, exercices, outils, techniques, statistiques, preuves, diff√©rences comportementales.
- Z√©ro omission. Z√©ro fluff. 100% de la valeur r√©elle du livre.
- Style narratif captivant; lisible, pro; sections structur√©es.
- Longueur minimale: 3000 mots si le contenu le permet.

CONTRAINTES DE MISE EN FORME:
- Interdiction d'utiliser des titres Markdown (#, ##, ###) ou des s√©parateurs '***'.
- Utiliser uniquement des titres en gras avec **, sans #.
- Pas d'excuses ni de m√©ta-commentaires. Pas de disclaimers.

STRUCTURE OBLIGATOIRE (utiliser exactement des titres en gras):

**üìö ${bookTitle}**

**‚ö° L'ESSENCE EN 30 SECONDES**
[R√©sum√© ultra-condens√© en 3-4 lignes qui donne envie de tout lire]

**üåç POURQUOI CE LIVRE EXISTE**
[Probl√®me trait√©, univers, motivation de l'auteur; style narratif avec questions/tension]

**üß† LA R√âVOLUTION MENTALE**
[Phrase d'intro]. Puis, lister CHACUN des principes du livre, avec NOM EXACT du principe en gras et d√©veloppement narratif/actionnable:
**[Nom exact du principe 1]** ‚Äî [explication narrative + application]
**[Nom exact du principe 2]** ‚Äî [exemples vivants]
[Continuer absolument pour CHAQUE principe, m√™me s'il y en a 50+]

**‚öîÔ∏è LES DIFF√âRENCES QUI CHANGENT TOUT**
Face √† [situation pr√©cise]: les gagnants [comportement exact] tandis que les perdants [comportement oppos√©]. Expliquer la cons√©quence concr√®te.
[D√©velopper toutes les diff√©rences comportementales du livre]

**üí¨ LES PHRASES QUI TRANSFORMENT**
"[Citation exacte]" ‚Äî [insight profond] sur [domaine].
[Inclure TOUTES les citations importantes avec leur contexte]

**üìñ LES HISTOIRES QUI MARQUENT √Ä VIE**
L'histoire de [protagoniste] ‚Äî [r√©cit complet captivant: situation, tension, r√©solution, le√ßon].
[Raconter TOUTES les anecdotes/cas d'√©tude]

**üéØ VOTRE ARSENAL D'OUTILS PRATIQUES**
**[Nom de l'exercice/technique]** ‚Äî [mode d'emploi, √©tapes, b√©n√©fices].
[D√©tailler TOUS les exercices, frameworks et outils]

**üìä LES PREUVES IRR√âFUTABLES**
**[Statistique exacte]** ‚Äî d√©montre que [implication].
[Inclure TOUTES les donn√©es/√©tudes]

**üöÄ VOTRE PLAN DE TRANSFORMATION**
Imm√©diatement: [actions concr√®tes].
Dans les 30 jours: [objectifs et m√©thode].
D'ici 6 mois: [vision moyen terme].
Votre nouvelle vie √† 1 an: [transformation attendue].

**üîó POUR APPROFONDIR**
[Livres, formations, outils recommand√©s par l'auteur et leur valeur]

**üíé VOS 3 TR√âSORS √Ä RETENIR**
1. [Le√ßon principale] ‚Äî transforme [aspect de votre vie]
2. [Deuxi√®me insight crucial] ‚Äî pour obtenir [r√©sultat]
3. [Troisi√®me r√©v√©lation] ‚Äî afin d'√©viter [erreur]

CRIT√àRES DE R√âUSSITE:
- EXHAUSTIVIT√â: l'utilisateur doit ressentir qu'il a lu le livre entier.
- ENGAGEMENT: chaque section est captivante et pousse √† continuer.
- VALEUR: z√©ro fluff; uniquement du contenu utile.
- ACTIONNABLE: √©l√©ments concrets √† appliquer imm√©diatement.

RAPPELS FORTS:
- N'invente rien. Tout doit venir du texte.
- Aucune en-t√™te Markdown (#, ##, ###) ni '***'. Titres en gras seulement.
- Respecte la structure ci-dessus, m√™me longue.`;

    case 'audio':
      return `${basePrompt}

üéØ **MISSION AUDIO/PODCAST:**
Capturer TOUS les enseignements, insights et moments cl√©s avec un formatage premium.

üé® **FORMAT PREMIUM:**

---

# üéµ **[TITRE DE L'AUDIO]**
## *R√©sum√© complet et structur√©*

### üéôÔ∏è **Informations Essentielles**
- **Dur√©e :** [Si disponible]
- **Intervenants :** [Noms et expertises]
- **Sujet principal :** [Th√®me central]

---

## üéØ **MESSAGES PRINCIPAUX**

### üåü **Point Cl√© #1 : [Titre]**
**D√©veloppement :** [Explication compl√®te]
**Citation :** "[Citation si disponible]"
**Application :** [Comment utiliser cette information]

---

## üí° **INSIGHTS ET R√âV√âLATIONS**

### üîç **Insight #1 :** [D√©couverte importante]
[Description d√©taill√©e de l'insight et pourquoi c'est important]

---

## üéØ **TAKEAWAYS PRATIQUES**
- ‚úÖ [Action concr√®te 1]
- ‚úÖ [Action concr√®te 2]
- ‚úÖ [Action concr√®te 3]

---`;

    case 'video':
      return `${basePrompt}

üéØ **MISSION VID√âO:**
Analyser TOUS les √©l√©ments visuels et auditifs avec un rendu premium.

üé® **FORMAT PREMIUM:**

---

# üé¨ **[TITRE DE LA VID√âO]**
## *Analyse compl√®te et d√©taill√©e*

### üì∫ **Informations G√©n√©rales**
- **Dur√©e :** [Si disponible]
- **Intervenants :** [Personnes pr√©sentes]
- **Format :** [Type de vid√©o]

---

## üéØ **CONTENU PRINCIPAL**

### üåü **Segment #1 : [Titre]**
**Contenu :** [Ce qui est dit et montr√©]
**√âl√©ments visuels :** [Graphiques, images, d√©monstrations]
**Message cl√© :** [Enseignement principal]

---

## üí° **ENSEIGNEMENTS MAJEURS**
- üéØ **Le√ßon 1 :** [Description]
- üéØ **Le√ßon 2 :** [Description]

---`;

    default:
      return `${basePrompt}

üéØ **ANALYSE G√âN√âRALE PREMIUM:**
Cr√©er un r√©sum√© exhaustif avec un formatage professionnel de haute qualit√©.`;
  }
}

// Prompts am√©lior√©s pour chunks ultra-d√©taill√©s
function getEnhancedChunkPromptForType(type, chunkIndex, totalChunks, bookTitle = 'Livre') {
  const basePrompt = `Tu es un expert en extraction EXHAUSTIVE. Tu analyses la partie ${chunkIndex}/${totalChunks} d'un ${type}.

üéØ MISSION CRITIQUE: EXTRAIRE MAXIMUM DE CONTENU - UTILISER TOUS LES TOKENS DISPONIBLES

EXTRACTION OBLIGATOIRE (NE PAS R√âSUMER, EXTRAIRE TOUT):
- TOUS les principes, r√®gles, lois mentionn√©s (noms exacts + explications compl√®tes)
- TOUTES les citations exactes (entre guillemets) avec contexte d√©taill√©
- TOUS les encadr√©s, tableaux, listes (reproduire int√©gralement)
- TOUS les exemples, histoires, anecdotes (r√©cits complets avec d√©tails)
- TOUTES les diff√©rences/comparaisons (situations pr√©cises + comportements oppos√©s)
- TOUS les chiffres, statistiques, pourcentages (valeurs exactes + contexte)
- TOUTES les techniques, m√©thodes, strat√©gies (√©tapes d√©taill√©es + applications)
- TOUS les conseils pratiques (mode d'emploi complet)
- TOUTES les r√©f√©rences √† des personnes/livres (noms + contributions)

‚ö†Ô∏è INSTRUCTION SP√âCIALE: Si ce chunk contient beaucoup d'informations, utiliser TOUS les tokens disponibles pour ne rien perdre. Pr√©f√©rer la compl√©tude √† la concision.

FORMAT EXIG√â: Structure claire avec emojis pour s√©parer les types d'information.`;

  if (type === 'book') {
    return basePrompt + `

üìã SP√âCIAL LIVRES D'ENRICHISSEMENT - EXTRACTION MILLIM√âTRIQUE:

**INSTRUCTIONS SP√âCIALES POUR CE CHUNK:**

Analysez ce chunk de texte et extrayez TOUS les √©l√©ments importants que vous y trouvez.

**M√âTHODE SIMPLE :**
1. Lisez tout le texte du chunk
2. Identifiez chaque principe, r√®gle, concept mentionn√©
3. Listez CHAQUE √©l√©ment trouv√© avec son nom exact
4. Donnez une explication claire pour chaque √©l√©ment

**FORMAT DE R√âPONSE :**

**PRINCIPES TROUV√âS (NOMS EXACTS + EXPLICATIONS) :**
1) [Nom exact] ‚Äî [explication/action]
2) [Nom exact] ‚Äî [explication/action]
[Lister TOUT]

**DIFF√âRENCES RICHES/PAUVRES (SITUATIONS + COMPORTEMENTS) :**
1) Face √† [situation] ‚Äî riches: [comportement exact] | pauvres: [comportement oppos√©] ‚Äî [cons√©quence]
[Lister TOUT]

**EXERCICES/TECHNIQUES (MODE D'EMPLOI) :**
1) [Nom exact] ‚Äî √©tapes: [1,2,3] ‚Äî b√©n√©fices: [...]
[Lister TOUT]

**CITATIONS EXACTES (AVEC CONTEXTE) :**
1) "[Citation mot pour mot]" ‚Äî [contexte/insight]
[Lister TOUT]

**HISTOIRES/ANECDOTES (R√âCIT + LE√áON) :**
1) [Titre/Protagoniste] ‚Äî [r√©cit synth√©tique] ‚Äî [le√ßon]
[Lister TOUT]

‚ö†Ô∏è **IMPORTANT:** Extrayez TOUT ce que vous trouvez dans ce chunk, ne sautez rien.

‚ö° **DIFF√âRENCES RICHES/PAUVRES - EXTRACTION NOMINATIVE:**

**DIFF√âRENCE PR√âCISE #1:** [Titre exact de la diff√©rence]
*Les riches [comportement exact], tandis que les pauvres [comportement oppos√© exact]*

**DIFF√âRENCE PR√âCISE #2:** [Autre titre exact]
*Les riches [action sp√©cifique], alors que les pauvres [action oppos√©e sp√©cifique]*

[...CONTINUER pour CHAQUE diff√©rence avec son TITRE EXACT...]

üí¨ **CITATIONS - EXTRACTION TEXTUELLE COMPL√àTE:**
- "[Citation compl√®te mot pour mot #1]"
- "[Citation compl√®te mot pour mot #2]"
[...TOUTES les citations exactes...]

üìñ **HISTOIRES - EXTRACTION PAR NOM:**
**HISTOIRE #1:** [Titre exact ou nom du protagoniste]
*[R√©cit complet de cette histoire sp√©cifique]*

üõ†Ô∏è **EXERCICES/TECHNIQUES - EXTRACTION PAR NOM:**
**EXERCICE SP√âCIFIQUE #1:** [Nom exact de l'exercice]
*[Description d√©taill√©e de cet exercice pr√©cis]*

üìä **STATISTIQUES - EXTRACTION CHIFFR√âE COMPL√àTE:**
- [Chiffre exact]% des [population pr√©cise] [action exacte]
- [Montant exact] [unit√©] [contexte pr√©cis]

üö® **INTERDICTION ABSOLUE DE G√âN√âRALISATION:**
‚ùå "Les principes mentaux incluent..." ‚Üí NON ! Nomme chaque principe
‚ùå "Parmi les diff√©rences importantes..." ‚Üí NON ! Liste chaque diff√©rence par son nom
‚ùå "Les concepts de base..." ‚Üí NON ! Titre exact de chaque concept
‚ùå "Les enseignements principaux..." ‚Üí NON ! Nom pr√©cis de chaque enseignement

‚úÖ **OBLIGATION:** Chaque √©l√©ment doit √™tre extrait avec son TITRE/NOM EXACT, pas en cat√©gorie g√©n√©rale.

FORMAT DE SORTIE EXIGE: Sections dans l'ordre ci-dessus avec listes compl√®tes. Z√©ro omission.`;
  }
  
  return basePrompt;
}

function getUltraDetailedCombinePrompt(type, chunksCount, bookTitle = 'Livre') {
  return `MISSION FINALE: COMBINER ${chunksCount} EXTRACTIONS EN UN R√âSUM√â EXHAUSTIF ET LISIBLE

OBJECTIF: Restituer 100% de la valeur du livre, dans le format obligatoire ci-dessous, sans inventer.

R√àGLES DE FORMATAGE (STRICTES):
- Aucun titre Markdown (#, ##, ###) et aucun s√©parateur '***'.
- Titres en gras avec ** uniquement. Pas d'autres syntaxes d'en-t√™te.
- Style narratif engageant. Fran√ßais naturel et professionnel.
 - Prioriser l'exhaustivit√© sur la concision: z√©ro omission. Z√©ro blabla.

SECTIONS OBLIGATOIRES (utiliser exactement ces titres en gras):
**üìö ${bookTitle}**
**‚ö° L'ESSENCE EN 30 SECONDES**
**üåç POURQUOI CE LIVRE EXISTE**
**üß† LA R√âVOLUTION MENTALE**
**‚öîÔ∏è LES DIFF√âRENCES QUI CHANGENT TOUT**
**üí¨ LES PHRASES QUI TRANSFORMENT**
**üìñ LES HISTOIRES QUI MARQUENT √Ä VIE**
**üéØ VOTRE ARSENAL D'OUTILS PRATIQUES**
**üìä LES PREUVES IRR√âFUTABLES**
**üöÄ VOTRE PLAN DE TRANSFORMATION**
**üîó POUR APPROFONDIR**
**üíé VOS 3 TR√âSORS √Ä RETENIR**

CONTENU √Ä INT√âGRER:
- Tous les principes et cadres (noms exacts + d√©veloppement narratif/actionnable)
- Toutes les diff√©rences comportementales d√©taill√©es
- Toutes les citations exactes avec contexte
- Toutes les histoires/anecdotes/cas d'√©tude complets
- Tous les exercices, outils, techniques avec mode d'emploi
- Toutes les statistiques/donn√©es/√©tudes

QUALIT√â:
- Longueur: viser 3000+ mots si le contenu le permet. Pas de limite dure; inclure tout.
- Z√©ro omission. Z√©ro fluff. Actionnable et concret.
- Fran√ßais clair, √©l√©gant, convaincant.

CONTRAINTE DE COMPL√âTUDE:
- N'OMETS AUCUN √©l√©ment des extractions. Si c'est trop long, continue l'√©num√©ration plut√¥t que de compresser.
- Pr√©f√®re les listes exhaustives et sections compactes aux paragraphes verbeux.
- Si un √©l√©ment ne rentre pas narrativement, liste-le quand m√™me sous la bonne section.`;
}

// Ancienne fonction pour compatibilit√©
function getChunkPromptForType(type, chunkIndex, totalChunks) {
  return getEnhancedChunkPromptForType(type, chunkIndex, totalChunks);
}

function getCombinePromptForType(type) {
  return getUltraDetailedCombinePrompt(type, 'plusieurs');
}

// Extraction ULTRA-COMPL√àTE de livre (optimis√©e vitesse + qualit√©)
export async function extractCompleteBookContent(pdfText, bookTitle = 'Livre') {
  const startTime = Date.now();

  try {
    console.log(`üöÄ EXTRACTION ULTRA-COMPL√àTE: ${bookTitle}`);
    console.log(`üìÑ Texte original: ${pdfText.length} caract√®res`);
    console.log(`‚ö° Mode: Parall√©lisation + Format Premium + Extraction Exhaustive`);

    // Personnaliser le prompt avec le titre r√©el
    const customOptions = {
      max_tokens: 16000,
      temperature: 0.02,
      top_p: 0.95,
      bookTitle: bookTitle // Passer le titre dans les options pour les prompts
    };

    const result = await summarizeText(pdfText, 'book', customOptions);

    const totalTime = Date.now() - startTime;
    console.log(`üéâ EXTRACTION ULTRA-COMPL√àTE termin√©e en ${totalTime}ms`);
    console.log(`‚ú® Format: Premium ChatGPT/Claude style`);
    console.log(`üìä Qualit√©: Extraction exhaustive de tous les encadr√©s/points cl√©s`);

    return {
      success: true,
      completeSummary: result,
      metadata: {
        bookTitle,
        originalTextLength: pdfText.length,
        totalProcessingTime: totalTime,
        extractionMethod: 'OPENAI_ULTRA_COMPLETE_PARALLEL',
        quality: 'ULTRA_PREMIUM_GRADE',
        features: [
          'Extraction exhaustive tous encadr√©s',
          'Format premium engageant',
          'Traitement parall√©lis√©',
          'Style ChatGPT/Claude',
          '100% valeur du livre'
        ]
      }
    };

  } catch (error) {
    console.error(`‚ùå Erreur extraction ultra-compl√®te: ${error.message}`);
    return {
      success: false,
      error: error.message,
      processingTime: Date.now() - startTime
    };
  }
}

// Fonctions utilitaires
export function getOpenAIQueueStatus() {
  return openaiQueue.getQueueStatus();
}

export function clearOpenAIQueue() {
  return openaiQueue.clearQueue();
}

// Test de connexion
export async function testOpenAIConnection() {
  try {
    const testMessage = await createChatCompletion([
      { role: 'user', content: 'Dis juste "OpenAI fonctionne" en fran√ßais.' }
    ], { max_tokens: 10 });
    
    console.log('‚úÖ Test OpenAI r√©ussi:', testMessage);
    return { success: true, message: testMessage };
  } catch (error) {
    console.error('‚ùå Test OpenAI √©chou√©:', error);
    return { success: false, error: error.message };
  }
}

console.log('‚úÖ Service OpenAI initialis√© avec GPT-4o mini');
