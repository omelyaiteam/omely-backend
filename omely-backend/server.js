// OMELY BACKEND AVEC GPT-4o mini - VERSION STABLE
import express from 'express';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';
import multer from 'multer';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import OpenAI from 'openai';
import { createChatCompletion } from './utils/openaiService.js';

// Charger les variables d'environnement
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

console.log('üöÄ D√âMARRAGE SERVEUR PRINCIPAL STABLE');

const app = express();
app.use(cors());
app.use(express.json());

// Configuration multer pour l'upload de fichiers
const upload = multer({
  dest: path.join(__dirname, 'ultra_temp'),
  limits: { fileSize: 500 * 1024 * 1024 } // 500MB max
});

console.log('‚úÖ Express et multer configur√©s');

// Imports asynchrones avec gestion d'erreurs (comme dans le serveur simplifi√©)
let services = {};
let servicesLoaded = false;

async function loadServices() {
  try {
    console.log('üîß Chargement des services...');

    // Service GPT-4o mini exclusivement
    try {
      const openaiModule = await import('./utils/openaiService.js');
      services.openai = {
        createChatCompletion: openaiModule.createChatCompletion,
        testOpenAIConnection: openaiModule.testOpenAIConnection,
        extractCompleteBookContent: openaiModule.extractCompleteBookContent,
        verifyGPT4oModelUsage: openaiModule.verifyDeepSeekModelUsage, // Alias pour compatibilit√©
        getGPT4oConfig: openaiModule.getDeepSeekConfig // Alias pour compatibilit√©
      };
      console.log('‚úÖ Service GPT-4o mini charg√© (GPT-4o mini remplac√©)');
    } catch (error) {
      console.log('‚ö†Ô∏è Service GPT-4o mini non disponible:', error.message);
      services.openai = null;
    }

    // Service transcription
    try {
      const transcribeModule = await import('./utils/transcribe.js');
      services.transcribe = transcribeModule.default;
      console.log('‚úÖ Service transcription charg√©');
    } catch (error) {
      console.log('‚ö†Ô∏è Service transcription non disponible:', error.message);
      services.transcribe = null;
    }

    // Service extraction audio
    try {
      const extractAudioModule = await import('./utils/extractAudio.js');
      services.extractAudio = extractAudioModule.default;
      console.log('‚úÖ Service extraction audio charg√©');
    } catch (error) {
      console.log('‚ö†Ô∏è Service extraction audio non disponible:', error.message);
      services.extractAudio = null;
    }

    // Service summarization
    try {
      const summarizeModule = await import('./utils/summarize.js');
      services.summarizeText = summarizeModule.default;
      console.log('‚úÖ Service summarization charg√©');
    } catch (error) {
      console.log('‚ö†Ô∏è Service summarization non disponible:', error.message);
      services.summarizeText = null;
    }

    servicesLoaded = true;
    console.log('üéâ Tous les services charg√©s avec succ√®s');

  } catch (error) {
    console.error('‚ùå Erreur lors du chargement des services:', error);
    servicesLoaded = false;
  }
}

// ==================== ROUTES SIMPLIFI√âES ====================

// Health check - Ultra rapide pour Fly.io
app.get('/health', (req, res) => {
  res.set('Cache-Control', 'no-cache');
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: 'v6.0-stable',
    servicesLoaded: servicesLoaded,
    gpt4oAvailable: services.openai ? true : false
  });
});

// Test route
app.get('/test', (req, res) => {
  res.json({
    message: 'OMELY Backend SIMPLIFI√â fonctionne !',
    timestamp: new Date().toISOString(),
    version: '6.0-simplified'
  });
});

// GPT-4o mini Verification Endpoint
app.get('/verify-gpt4o', async (req, res) => {
  try {
    console.log('üîç Requ√™te de v√©rification GPT-4o mini re√ßue');

    if (!services.openai) {
      return res.status(503).json({
        timestamp: new Date().toISOString(),
        service: 'GPT-4o mini',
        verification: {
          status: 'SERVICE_UNAVAILABLE',
          message: 'Service GPT-4o mini non charg√©',
          error: 'Le service GPT-4o mini n\'a pas pu √™tre initialis√©'
        }
      });
    }

    const config = services.openai.getGPT4oConfig();
    const modelVerification = await services.openai.verifyGPT4oModelUsage();

    const response = {
      timestamp: new Date().toISOString(),
      service: 'GPT-4o mini',
      verification: {
        config: {
          hasApiKey: config.hasApiKey,
          model: config.model,
          baseURL: config.baseURL,
          verifyModel: config.verifyModel
        },
        modelCheck: {
          success: modelVerification.success,
          requestedModel: modelVerification.requestedModel,
          actualModel: modelVerification.actualModel,
          baseURL: modelVerification.baseURL,
          error: modelVerification.error
        },
        status: modelVerification.success && config.hasApiKey ? 'ACTIVE' : 'INACTIVE',
        message: modelVerification.success && config.hasApiKey
          ? '‚úÖ API utilise exclusivement GPT-4o mini'
          : '‚ùå Probl√®me de configuration d√©tect√©'
      }
    };

    res.json(response);
  } catch (error) {
    console.error('‚ùå Erreur v√©rification GPT-4o mini:', error);
    res.status(500).json({
      error: 'Erreur de v√©rification GPT-4o mini',
      message: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Route de debug pour lister toutes les routes
app.get('/debug/routes', (req, res) => {
  const routes = [];
  app._router.stack.forEach((middleware) => {
    if (middleware.route) {
      routes.push({
        path: middleware.route.path,
        methods: Object.keys(middleware.route.methods)
      });
    }
  });
  res.json({
    status: 'OK',
    message: 'Routes disponibles',
    routes: routes,
    total: routes.length
  });
});

// Route de test temporaire
app.get('/test-quiz-route', (req, res) => {
  console.log('üß™ Route de test appel√©e √†', new Date().toISOString());
  res.json({
    status: 'OK',
    message: 'Route quiz is working!',
    timestamp: new Date().toISOString(),
    routes: ['/api/generate-quiz', '/api/generate-pretest', '/test-quiz-route']
  });
});

// ==================== ROUTE QUIZ IMMERSIVE ====================

// Route pour les chat completions (remplace Gemini) avec m√©moire
app.post('/chat/completion', async (req, res) => {
  const startTime = Date.now();
  
  try {
    console.log('ü§ñ Nouvelle requ√™te chat completion GPT-4o mini avec m√©moire');
    
    const { 
      systemPrompt, 
      userMessage, 
      contextualPrompt = '', 
      conversationHistory = [], 
      userId = null, 
      options = {} 
    } = req.body;
    
    if (!userMessage) {
      return res.status(400).json({ 
        success: false, 
        error: 'Message utilisateur requis',
        processingTime: Date.now() - startTime
      });
    }
    
    console.log(`üí¨ Chat avec m√©moire: ${userMessage.substring(0, 50)}... (User: ${userId || 'anonymous'})`);
    console.log(`üìö Historique: ${conversationHistory.length} messages`);
    
    // Optimisation m√©moire: Limiter l'historique 
    const optimizedHistory = conversationHistory.slice(-MEMORY_CONFIG.maxMessagesPerUser);
    
    if (conversationHistory.length > MEMORY_CONFIG.maxMessagesPerUser) {
      console.log(`üìä Historique optimis√©: ${conversationHistory.length} ‚Üí ${optimizedHistory.length} messages`);
    }
    
    // Calculer l'utilisation m√©moire
    const memoryUsage = calculateMemoryUsage(optimizedHistory);
    console.log(`üìä Utilisation m√©moire: ${memoryUsage.estimatedKB}KB/${memoryUsage.limitKB}KB (${memoryUsage.usagePercent}%) - ${memoryUsage.messages} messages, ${memoryUsage.summaries} r√©sum√©s`);
    
    // Utiliser la fonction chatWithMemory existante (maintenant avec GPT-4o mini)
    const { success, response, context } = await chatWithMemory(userMessage, optimizedHistory, userId);
    
    if (!success) {
      throw new Error('Chat IA avec m√©moire √©chou√©');
    }
    
    const totalTime = Date.now() - startTime;
    console.log(`‚úÖ Chat completion avec m√©moire r√©ussi en ${totalTime}ms`);
    
    res.json({
      success: true,
      response: response,
      model: 'gpt-4o-mini',
      provider: 'OpenAI',
      metadata: {
        source: 'omely-chat-gpt4o',
        processingTime: totalTime,
        contextLength: context.length,
        memoryOptimized: true,
        historyLength: optimizedHistory.length,
        memoryUsage: memoryUsage,
        provider: 'OpenAI',
        model: 'gpt-4o-mini'
      }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur chat completion avec m√©moire:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Erreur interne du serveur',
      processingTime: Date.now() - startTime
    });
  }
});

// Route de test GPT-4o mini
app.get('/test/openai', async (req, res) => {
  try {
    const result = await testOpenAIConnection();
    res.json(result);
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Configuration GPT-4o mini exclusivement
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || 'sk-proj-your-key-here'
});

// Configuration GPT-4o mini optimis√©e
const GPT4O_CONFIG = {
  apiKey: process.env.OPENAI_API_KEY || 'your-openai-api-key-here',
  model: 'gpt-4o-mini',
  maxTokens: 1000
};

// Ancienne config GPT-4o mini supprim√©e - maintenant 100% GPT-4o mini

// Configuration optimis√©e pour EXTRACTION COMPL√àTE
const OPTIMIZATION_CONFIG = {
  maxTextLength: 150000, // Augment√© pour traiter de gros livres
  maxSummaryLength: 15000, // R√©sum√©s d√©taill√©s et complets
  concurrentProcessing: true, // Traitement parall√®le
  cacheEnabled: false, // Pas de cache pour √©viter les r√©sum√©s partiels
  timeoutMs: 180000, // 3 minutes pour extraction compl√®te
  chunkSize: 50000, // R√©duit √† 50k pour √©viter les timeouts Gemini
  overlapSize: 3000 // Chevauchement entre chunks r√©duit
};

// Configuration m√©moire MVP (500MB Supabase)
const MEMORY_CONFIG = {
  maxStoragePerUser: 100 * 1024, // 100KB par utilisateur
  maxMessagesPerUser: 50, // 50 messages max par conversation
  maxSummariesPerUser: 10, // 10 r√©sum√©s max par utilisateur
  maxTotalUsers: 5000, // 5000 utilisateurs max pour MVP
  estimatedStoragePerUser: {
    messages: 25 * 1024, // 25KB pour messages
    summaries: 50 * 1024, // 50KB pour r√©sum√©s
    metadata: 25 * 1024 // 25KB pour m√©tadonn√©es
  }
};

// Fonction de calcul d'utilisation m√©moire
function calculateMemoryUsage(conversationHistory = []) {
  const messages = conversationHistory.filter(msg => msg.role === 'user' || msg.role === 'assistant');
  const summaries = conversationHistory.filter(msg => 
    msg.role === 'assistant' && 
    (msg.content.includes('üìö') || msg.content.includes('üìÑ') || msg.content.includes('üé¨') || 
     msg.content.includes('üéµ') || msg.content.includes('üì∫') || msg.content.includes('R√âSUM√â') ||
     msg.content.includes('üìù PDF Summary') || msg.content.includes('üìù Video Summary') ||
     msg.content.includes('üìù Audio Summary') || msg.content.includes('üìù YouTube Summary'))
  );
  
  const totalChars = conversationHistory.reduce((sum, msg) => sum + msg.content.length, 0);
  const estimatedBytes = totalChars * 2; // UTF-8 estimation
  
  return {
    messages: messages.length,
    summaries: summaries.length,
    totalChars,
    estimatedBytes,
    estimatedKB: Math.round(estimatedBytes / 1024 * 100) / 100,
    limitKB: MEMORY_CONFIG.maxStoragePerUser / 1024,
    usagePercent: Math.round((estimatedBytes / MEMORY_CONFIG.maxStoragePerUser) * 100)
  };
}

// Cr√©er le dossier temp
const tempDir = path.join(__dirname, 'ultra_temp');
await fs.mkdir(tempDir, { recursive: true });

// Configuration multer (already declared above)

// FONCTION EXTRACTION TEXTE PDF AVEC PDFJS-DIST (EXTRACTION R√âELLE)
async function extractTextFromPDF(pdfBuffer) {
  const startTime = Date.now();
  
  try {
    console.log(`üìÑ Extraction texte PDF avec pdfjs-dist (extraction r√©elle)...`);
    
    // V√©rifier que le buffer est valide
    if (!pdfBuffer || pdfBuffer.length === 0) {
      throw new Error('Buffer PDF invalide ou vide');
    }
    
    // V√©rifier que c'est bien un PDF (magic number)
    const pdfHeader = pdfBuffer.toString('ascii', 0, 4);
    if (pdfHeader !== '%PDF') {
      throw new Error('Le fichier ne semble pas √™tre un PDF valide');
    }
    
    console.log(`üìÑ Buffer PDF re√ßu: ${pdfBuffer.length} bytes, header: ${pdfHeader}`);
    
    try {
      // Importer pdfjs-dist de mani√®re s√©curis√©e
      let pdfjsLib;
      try {
        const pdfjsModule = await import('pdfjs-dist');
        pdfjsLib = pdfjsModule.default || pdfjsModule;
        console.log(`üìÑ pdfjs-dist import√© avec succ√®s`);
      } catch (importError) {
        console.error(`‚ùå Erreur import pdfjs-dist: ${importError.message}`);
        throw new Error('Impossible de charger pdfjs-dist');
      }
      
      // D√©sactiver le worker pour Node.js
      if (pdfjsLib.GlobalWorkerOptions) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = false;
      }
      
      // Convertir le buffer en Uint8Array
      const uint8Array = new Uint8Array(pdfBuffer);
      
      // Charger le PDF avec pdfjs-dist
      console.log(`üìÑ Chargement du PDF avec pdfjs-dist...`);
      const loadingTask = pdfjsLib.getDocument({ data: uint8Array });
      const pdfDocument = await loadingTask.promise;
      
      const numPages = pdfDocument.numPages;
      console.log(`üìÑ PDF charg√©: ${numPages} pages d√©tect√©es`);
      
      // Extraire le texte de chaque page
      let fullText = '';
      let totalTextLength = 0;
      
      for (let i = 1; i <= numPages; i++) {
        console.log(`üìÑ Extraction page ${i}/${numPages}...`);
        
        try {
          const page = await pdfDocument.getPage(i);
          
          // Extraire le contenu textuel de la page
          const textContent = await page.getTextContent();
          
          let pageText = '';
          for (const item of textContent.items) {
            if (item.str) {
              pageText += item.str + ' ';
            }
          }
          
          // Nettoyer le texte de la page
          pageText = pageText
            .replace(/\s+/g, ' ')
            .trim();
          
          if (pageText) {
            fullText += pageText + '\n\n';
            totalTextLength += pageText.length;
            console.log(`üìÑ Page ${i}: ${pageText.length} caract√®res extraits`);
          } else {
            console.log(`üìÑ Page ${i}: Aucun texte d√©tect√©`);
          }
          
        } catch (pageError) {
          console.warn(`‚ö†Ô∏è Erreur extraction page ${i}: ${pageError.message}`);
        }
      }
      
      // Nettoyer le texte final
      fullText = fullText
        .replace(/\n\s*\n/g, '\n') // Supprimer les lignes vides multiples
        .replace(/\s+/g, ' ') // Normaliser les espaces
        .trim();
      
      console.log(`üìÑ Extraction termin√©e: ${fullText.length} caract√®res extraits au total`);
      
      // V√©rifier que l'extraction a fonctionn√©
      if (!fullText || fullText.length < 100) {
        console.warn(`‚ö†Ô∏è Texte extrait trop court (${fullText.length} caract√®res), tentative d'extraction alternative...`);
        
        // Tentative d'extraction alternative avec une approche diff√©rente
        try {
          let alternativeText = '';
          
          for (let i = 1; i <= numPages; i++) {
            const page = await pdfDocument.getPage(i);
            const viewport = page.getViewport({ scale: 1.0 });
            
            // Essayer d'extraire le contenu de la page avec une approche diff√©rente
            const textContent = await page.getTextContent();
            if (textContent && textContent.items && textContent.items.length > 0) {
              alternativeText += `Page ${i} (${viewport.width}x${viewport.height}): ${textContent.items.length} √©l√©ments de texte\n`;
            }
          }
          
          if (alternativeText) {
            fullText = alternativeText;
          } else {
            throw new Error('Aucune m√©thode d\'extraction n\'a fonctionn√©');
          }
        } catch (altError) {
          throw new Error(`Extraction alternative √©chou√©e: ${altError.message}`);
        }
      }
      
      // Gestion intelligente selon la taille du document
      let optimizedText = fullText;
      if (optimizedText.length > OPTIMIZATION_CONFIG.maxTextLength) {
        console.log(`üìö Document volumineux d√©tect√© (${optimizedText.length} caract√®res) - Conservation compl√®te pour extraction professionnelle`);
        // Conserver le texte complet pour extraction professionnelle
        // Le syst√®me de chunks se chargera de la gestion
      } else {
        console.log(`üìÑ Document standard (${optimizedText.length} caract√®res) - Traitement direct`);
      }
      
      const extractionTime = Date.now() - startTime;
      console.log(`‚úÖ Texte PDF extrait en ${extractionTime}ms (${optimizedText.length} caract√®res, ${numPages} pages)`);
      
      return {
        success: true,
        text: optimizedText,
        extractionTime,
        pages: numPages,
        originalLength: fullText.length
      };
      
    } catch (extractError) {
      console.error(`‚ùå Erreur extraction pdfjs-dist: ${extractError.message}`);
      throw new Error(`√âchec de l'extraction PDF: ${extractError.message}`);
    }
    
  } catch (error) {
    console.error(`‚ùå Erreur extraction PDF: ${error.message}`);
    // Retourner une erreur plus claire
    throw new Error(`√âchec de l'extraction PDF: ${error.message}`);
  }
}

// FONCTION TRANSCRIPTION AUDIO OPTIMIS√âE (MP3/MP4) - VERSION M√âMOIRE OPTIMIS√âE
async function transcribeAudio(audioFilePath) {
  const startTime = Date.now();

  try {
    console.log(`üéµ Transcription audio optimis√©e avec Whisper...`);

    // Utiliser directement la nouvelle fonction transcribe optimis√©e
    const transcript = await transcribe(audioFilePath);
    const transcriptionTime = Date.now() - startTime;

    // Optimisation: Limiter la longueur de la transcription si n√©cessaire
    let finalTranscript = transcript;
    if (transcript.length > OPTIMIZATION_CONFIG.maxTextLength) {
      finalTranscript = transcript.substring(0, OPTIMIZATION_CONFIG.maxTextLength) + '...';
      console.log(`üìù Transcription tronqu√©e √† ${OPTIMIZATION_CONFIG.maxTextLength} caract√®res pour optimiser la vitesse`);
    }

    console.log(`‚úÖ Transcription termin√©e en ${transcriptionTime}ms (${finalTranscript.length} caract√®res)`);

    return {
      success: true,
      transcript: finalTranscript,
      transcriptionTime: transcriptionTime,
      originalLength: transcript.length
    };
  } catch (error) {
    console.error(`‚ùå Erreur transcription: ${error.message}`);
    return {
      success: false,
      transcript: '',
      transcriptionTime: Date.now() - startTime,
      error: error.message
    };
  }
}

// FONCTION EXTRACTION AUDIO DEPUIS MP4 OPTIMIS√âE - VERSION M√âMOIRE OPTIMIS√âE
async function extractAudioFromMP4(videoBuffer) {
  const startTime = Date.now();
  const videoFile = path.join(tempDir, `video_${Date.now()}.mp4`);

  try {
    console.log(`üé¨ Extraction audio optimis√©e depuis MP4...`);

    // √âcrire le fichier vid√©o temporaire
    await fs.writeFile(videoFile, videoBuffer);

    // Utiliser la nouvelle fonction extractAudio optimis√©e
    const audioFilePath = await extractAudio(videoFile);
    const extractionTime = Date.now() - startTime;

    console.log(`‚úÖ Audio extrait en ${extractionTime}ms`);

    // Nettoyer le fichier vid√©o temporaire
    await fs.unlink(videoFile).catch(() => {});

    return {
      success: true,
      audioFilePath: audioFilePath, // Retourner le chemin au lieu du buffer
      extractionTime
    };
  } catch (error) {
    console.error(`‚ùå Erreur extraction MP4: ${error.message}`);
    // Nettoyer en cas d'erreur
    await fs.unlink(videoFile).catch(() => {});
    return {
      success: false,
      audioFilePath: null,
      extractionTime: Date.now() - startTime,
      error: error.message
    };
  }
}



// FONCTIONS DE CHUNKING POUR GROS DOCUMENTS
function processChunk(text, chunkIndex, totalChunks, type = 'book') {
  const chunkPrompt = `EXTRACTION PROFESSIONNELLE - CHUNK ${chunkIndex + 1}/${totalChunks}

‚ö†Ô∏è MISSION: Extraire TOUS les principes d'enrichissement de ce fragment avec pr√©cision chirurgicale.

TEXTE √Ä ANALYSER (FRAGMENT ${chunkIndex + 1}/${totalChunks}):
${text}

INSTRUCTIONS OPTIMIS√âES POUR CE CHUNK:
- Extraire les principes d'enrichissement ESSENTIELS (3-5 par chunk)
- Capturer les diff√©rences riches/pauvres PRINCIPALES
- Noter les conseils financiers UNIVERSELS et APPLICABLES
- Ignorer les montants, prix et chiffres sp√©cifiques
- Se concentrer sur les CONCEPTS g√©n√©ralisables
- Extraire les citations INSPIRANTES uniquement
- √âviter les d√©tails num√©riques inutiles
- Privil√©gier les enseignements ACTIONNABLES

FORMAT STRUCTUR√â POUR CE CHUNK:

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üî∏ **CHUNK ${chunkIndex + 1}/${totalChunks} - EXTRACTION CIBL√âE**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üîë **PRINCIPES ESSENTIELS**
**1.** [Principe principal 1 - concis]
**2.** [Principe principal 2 - concis]
**3.** [Principe principal 3 - concis]

---

## ‚ö° **CONTRASTES RICHES/PAUVRES**
‚Ä¢ **Riches :** [Comportement/mentalit√© riche]
  **vs Pauvres :** [Comportement/mentalit√© pauvre]

‚Ä¢ **Riches :** [Comportement/mentalit√© riche]
  **vs Pauvres :** [Comportement/mentalit√© pauvre]

---

## üí∞ **TECHNIQUES APPLICABLES**
üîß **[Technique 1] :** [Description courte]
üîß **[Technique 2] :** [Description courte]
üîß **[Technique 3] :** [Description courte]

---

## üí¨ **CITATIONS MARQUANTES**
> *"[Citation inspirante du chunk]"*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ö†Ô∏è Extraire uniquement ce qui est R√âELLEMENT dans ce fragment, ne pas inventer.`;

  return chunkPrompt;
}

async function combineChunkSummaries(chunkSummaries, originalTextLength, totalChunks) {
  const combinePrompt = `SYNTH√àSE FINALE - COMBINAISON DE ${totalChunks} CHUNKS

MISSION CRITIQUE: Combiner TOUS les chunks pour cr√©er un r√©sum√© COMPLET qui capture 100% de la valeur du livre (${originalTextLength} caract√®res).

EXTRACTIONS DES CHUNKS:
${chunkSummaries.map((summary, index) => `\n--- CHUNK ${index + 1} ---\n${summary}`).join('\n')}

INSTRUCTIONS DE SYNTH√àSE FINALE OPTIMIS√âE:
- Combiner les principes d'enrichissement ESSENTIELS (15-25 max)
- √âliminer les doublons et d√©tails num√©riques sp√©cifiques
- Organiser par cat√©gories PRATIQUES et ACTIONNABLES
- Cr√©er un r√©sum√© COMPLET mais CONCIS (5000-8000 caract√®res)
- Ignorer les montants, prix et chiffres sp√©cifiques
- REMPLIR TOUTES LES SECTIONS - aucune section vide ou "trop longue"
- INTERDICTION absolue d'inclure "Analysis:" ou messages d'aide
- Se concentrer sur les CONCEPTS applicables universellement

UTILISER LE FORMAT VISUELLEMENT ATTRACTIF SUIVANT :

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìö **R√âSUM√â COMPLET PROFESSIONNEL**
üìñ **[TITRE DU LIVRE]** - 100% VALEUR CAPTUR√âE (${totalChunks} PARTIES ANALYS√âES)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üîë **PRINCIPES D'ENRICHISSEMENT CL√âS**
*Les r√®gles fondamentales extraites de ${totalChunks} parties du livre*

**1.** [Principe 1 combin√© - court et percutant]
   ‚Üí **Application pratique :** [Comment l'appliquer]

**2.** [Principe 2 combin√© - court et percutant]
   ‚Üí **Application pratique :** [Comment l'appliquer]

[Continuer avec les principes les plus importants - 15-20 maximum]

---

## ‚ö° **MENTALIT√âS : RICHES vs PAUVRES**
*Les diff√©rences de pens√©e synth√©tis√©es*

| üí∞ **LES RICHES** | üí∏ **LES PAUVRES** |
|-------------------|---------------------|
| ‚úÖ [Mentalit√© riche synth√©tis√©e] | ‚ùå [Mentalit√© pauvre synth√©tis√©e] |
| ‚úÖ [Mentalit√© riche synth√©tis√©e] | ‚ùå [Mentalit√© pauvre synth√©tis√©e] |

---

## üí∞ **STRAT√âGIES FINANCI√àRES ESSENTIELLES**
*Les techniques qui g√©n√®rent la richesse - synth√®se compl√®te*

### üìà **Investissement & Placement**
‚Ä¢ [Strat√©gie combin√©e 1]
‚Ä¢ [Strat√©gie combin√©e 2]

### üè† **Patrimoine & Actifs**
‚Ä¢ [M√©thode combin√©e 1]
‚Ä¢ [M√©thode combin√©e 2]

---

## üéØ **PLAN D'ACTION IMM√âDIAT**
*Actions synth√©tis√©es de toutes les parties*

### üìÖ **CETTE SEMAINE :**
1. [Action imm√©diate synth√©tis√©e]
2. [Action imm√©diate synth√©tis√©e]

### üìÖ **CE MOIS-CI :**
1. [Action moyen terme synth√©tis√©e]
2. [Action moyen terme synth√©tis√©e]

### üìÖ **CETTE ANN√âE :**
1. [Objectif long terme synth√©tis√©]
2. [Objectif long terme synth√©tis√©]

---

## üí¨ **CITATIONS INSPIRANTES DU LIVRE**
*Les meilleures phrases extraites de ${totalChunks} parties*

> üåü *"[Citation puissante du livre]"*
> üåü *"[Citation puissante du livre]"*
> üåü *"[Citation puissante du livre]"*

---

## ‚ùå **PI√àGES √Ä √âVITER ABSOLUMENT**
*Les erreurs identifi√©es dans le livre complet*

üö´ **[Erreur synth√©tis√©e]** - *Pourquoi c'est dangereux*
üö´ **[Erreur synth√©tis√©e]** - *Pourquoi c'est dangereux*

---

## üõ†Ô∏è **OUTILS ET TECHNIQUES PRATIQUES**
*Les m√©thodes concr√®tes du livre complet*

**üîß [Technique synth√©tis√©e] :**
   ‚Ä¢ √âtape pratique 1
   ‚Ä¢ √âtape pratique 2

**üîß [Technique synth√©tis√©e] :**
   ‚Ä¢ √âtape pratique 1
   ‚Ä¢ √âtape pratique 2

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚úÖ **R√âSUM√â PROFESSIONNEL COMPLET**
üéØ **SYNTH√àSE DE ${totalChunks} PARTIES - PR√äT POUR APPLICATION**
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`;

  return combinePrompt;
}

// FONCTION DE CHUNKING INTELLIGENT CORRIG√âE
function splitTextIntoIntelligentChunks(text) {
  const chunks = [];
  const maxChunkSize = OPTIMIZATION_CONFIG.chunkSize; // 80000
  const overlapSize = OPTIMIZATION_CONFIG.overlapSize; // 5000
  
  // Si le texte est petit, retourner tel quel
  if (text.length <= maxChunkSize) {
    return [text];
  }
  
  console.log(`üìö D√©coupage intelligent du texte (${text.length} caract√®res) en chunks de ${maxChunkSize} caract√®res`);
  
  // M√©thode 1: Essayer de d√©couper par paragraphes
  let paragraphs = text.split(/\n\s*\n/);
  
  // Si les paragraphes sont trop gros, d√©couper par phrases
  if (paragraphs.some(p => p.length > maxChunkSize)) {
    console.log(`üìö Paragraphes trop volumineux, d√©coupage par phrases...`);
    paragraphs = text.split(/\.\s+/);
  }
  
  // Si les phrases sont encore trop grosses, d√©coupage forc√© par caract√®res
  if (paragraphs.some(p => p.length > maxChunkSize)) {
    console.log(`üìö Phrases trop volumineuses, d√©coupage forc√© par caract√®res...`);
    return splitTextByCharacters(text, maxChunkSize, overlapSize);
  }
  
  let currentChunk = '';
  
  for (let i = 0; i < paragraphs.length; i++) {
    const paragraph = paragraphs[i];
    const potentialChunk = currentChunk + (currentChunk ? '\n\n' : '') + paragraph;
    
    // Si ajouter ce paragraphe d√©passe la taille max
    if (potentialChunk.length > maxChunkSize && currentChunk.length > 0) {
      // Finaliser le chunk actuel
      chunks.push(currentChunk.trim());
      
      // Commencer un nouveau chunk avec chevauchement
      const overlap = currentChunk.slice(-Math.min(overlapSize, currentChunk.length));
      currentChunk = overlap + '\n\n' + paragraph;
    } else {
      // Ajouter le paragraphe au chunk actuel
      currentChunk = potentialChunk;
    }
    
    // S√©curit√©: si le chunk actuel d√©passe d√©j√† la taille max
    if (currentChunk.length > maxChunkSize) {
      // Forcer la finalisation
      chunks.push(currentChunk.substring(0, maxChunkSize).trim());
      currentChunk = currentChunk.substring(maxChunkSize - overlapSize);
    }
  }
  
  // Ajouter le dernier chunk
  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }
  
  console.log(`üìö Texte d√©coup√© en ${chunks.length} chunks intelligents`);
  console.log(`üìö Tailles des chunks: ${chunks.map(c => c.length).join(', ')} caract√®res`);
  
  return chunks;
}

// FONCTION DE D√âCOUPAGE FORC√â PAR CARACT√àRES
function splitTextByCharacters(text, maxChunkSize, overlapSize) {
  const chunks = [];
  let position = 0;
  
  while (position < text.length) {
    const endPosition = Math.min(position + maxChunkSize, text.length);
    let chunk = text.substring(position, endPosition);
    
    // Essayer de finir sur un espace ou une ponctuation pour √©viter de couper les mots
    if (endPosition < text.length) {
      const lastSpace = chunk.lastIndexOf(' ');
      const lastPeriod = chunk.lastIndexOf('.');
      const lastNewline = chunk.lastIndexOf('\n');
      
      const bestCut = Math.max(lastSpace, lastPeriod, lastNewline);
      if (bestCut > maxChunkSize * 0.8) { // Au moins 80% du chunk
        chunk = chunk.substring(0, bestCut);
        position += bestCut;
      } else {
        position = endPosition;
      }
    } else {
      position = endPosition;
    }
    
    chunks.push(chunk.trim());
    
    // Reculer un peu pour le chevauchement (sauf pour le dernier chunk)
    if (position < text.length) {
      position = Math.max(position - overlapSize, position - maxChunkSize + 1);
    }
  }
  
  console.log(`üìö D√©coupage forc√©: ${chunks.length} chunks de tailles ${chunks.map(c => c.length).join(', ')}`);
  return chunks;
}

// FONCTION D'APPEL OPENAI AVEC RETRY ET GESTION D'ERREURS (remplace Gemini)
async function callGPT4oWithRetry(prompt, context = '', maxRetries = 3) {
  try {
    console.log(`üîÑ Appel GPT-4o mini pour ${context}...`);

    // Construire les messages pour GPT-4o mini
    const messages = [
      { role: 'user', content: prompt }
    ];

    // Utiliser le service GPT-4o mini centralis√©
    const response = await createChatCompletion(messages, {
      max_tokens: 3000,
      temperature: 0.1
    });

    console.log(`‚úÖ Appel GPT-4o mini r√©ussi pour ${context}`);
    return response;

  } catch (error) {
    console.error(`‚ùå Erreur GPT-4o mini pour ${context}: ${error.message}`);
    throw new Error(`√âchec GPT-4o mini pour ${context}: ${error.message}`);
  }
}

// Alias pour la compatibilit√© (remplace l'ancienne fonction Gemini)
const callGeminiWithRetry = callGPT4oWithRetry;

// FONCTION SUMMARIZATION CONTENT (version ULTRA-D√âTAILL√âE et robuste)
async function summarizeContent(text, type = 'general', options = {}) {
  const startTime = Date.now();

  try {
    console.log(`‚ö° D√©marrage summarization content via service GPT-4o mini centralis√©...`);
    // Mapper le type pour le service central (pdf ‚Üí book)
    const targetType = (type === 'pdf' || type === 'book')
      ? 'book'
      : (type === 'audio'
        ? 'audio'
        : (type === 'video' ? 'video' : 'general'));
    const result = await summarizeText(text, targetType, options);
    const processingTime = Date.now() - startTime;

    return {
      success: true,
      summary: result,
      summarizationTime: processingTime,
      method: 'OPENAI_SERVICE'
    };
  } catch (error) {
    console.error(`‚ùå Erreur summarization content: ${error.message}`);
    return {
      success: false,
      error: error.message,
      summarizationTime: Date.now() - startTime
    };
  }
}

// FONCTION CHAT IA AVEC M√âMOIRE OPTIMIS√âE (GPT-4o mini)
async function chatWithMemory(userMessage, conversationHistory = [], userId = null) {
  try {
    console.log(`üí¨ Chat IA GPT-4o mini avec m√©moire optimis√©e...`);
    
    // D√©tecter la langue du message utilisateur
    const isEnglish = /^[a-zA-Z\s.,!?;:'"()-]+$/.test(userMessage) && !/[√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]/i.test(userMessage);
    const userLanguage = isEnglish ? 'English' : 'French';
    
    // Optimisation: Extraire et conserver TOUS les r√©sum√©s (identification am√©lior√©e)
    const summaries = conversationHistory.filter(msg => 
      msg.role === 'assistant' && 
      (msg.content.includes('üìö') || msg.content.includes('üìÑ') || msg.content.includes('üé¨') || 
       msg.content.includes('üéµ') || msg.content.includes('üì∫') || msg.content.includes('R√âSUM√â') ||
       msg.content.includes('üìù PDF Summary') || msg.content.includes('üìù Video Summary') ||
       msg.content.includes('üìù Audio Summary') || msg.content.includes('üìù YouTube Summary'))
    );
    
    // Construire le prompt syst√®me
    let systemPrompt = `Tu es OMELY, un assistant IA sp√©cialis√© dans l'optimisation cognitive et l'apprentissage. Tu as une m√©moire des conversations pr√©c√©dentes et des r√©sum√©s que tu as cr√©√©s.

SYST√àME: L'utilisateur parle en ${userLanguage}. Tu dois r√©pondre dans la M√äME LANGUE que l'utilisateur (${userLanguage}) et rester dans ton r√¥le d'assistant OMELY sp√©cialis√© dans l'optimisation cognitive. Utilise GPT-4o mini pour des r√©ponses rapides et pr√©cises.`;

    if (summaries.length > 0) {
      console.log(`üìö ${summaries.length} r√©sum√©s trouv√©s en m√©moire`);
      systemPrompt += `\n\nM√âMOIRE DES R√âSUM√âS CR√â√âS (conserv√©s en m√©moire):\n`;
      summaries.forEach((summary, index) => {
        // Conserver un extrait des r√©sum√©s pour √©viter les tokens trop longs
        const excerpt = summary.content.length > 1000 ? 
          summary.content.substring(0, 1000) + '...' : 
          summary.content;
        systemPrompt += `\n--- R√âSUM√â ${index + 1} ---\n${excerpt}\n`;
      });
    }

    // Construire les messages pour GPT-4o mini
    const messages = [
      { role: 'system', content: systemPrompt }
    ];
    
    // Ajouter l'historique r√©cent
    const recentMessages = conversationHistory.slice(-10); // R√©duire pour optimiser les tokens
    recentMessages.forEach(msg => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    
    // Ajouter le message actuel
    messages.push({
      role: 'user',
      content: userMessage
    });

    // Appel via le service GPT-4o mini
    const response = await createChatCompletion(messages, {
      max_tokens: 1200,
      temperature: 0.7
    });
    
    console.log(`‚úÖ Chat IA GPT-4o mini r√©ussi (${userLanguage})`);
    
    return {
      success: true,
      response: response,
      context: systemPrompt.substring(0, 500) + '...' // Pour debug
    };
  } catch (error) {
    console.error(`‚ùå Erreur chat IA GPT-4o mini: ${error.message}`);
    throw error;
  }
}

// ROUTES API

// Chat IA avec m√©moire optimis√©e pour MVP
app.post('/chat', async (req, res) => {
  const startTime = Date.now();
  
  try {
    const { message, conversationHistory = [], userId = null } = req.body;
    
    if (!message) {
      return res.status(400).json({
        status: 'error',
        message: 'Message required',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üí¨ Chat IA demand√©: ${message.substring(0, 50)}... (User: ${userId || 'anonymous'})`);

    // Optimisation m√©moire: Limiter l'historique √† 50 messages max pour MVP
    const optimizedHistory = conversationHistory.slice(-MEMORY_CONFIG.maxMessagesPerUser);
    
    if (conversationHistory.length > MEMORY_CONFIG.maxMessagesPerUser) {
      console.log(`üìä Historique optimis√©: ${conversationHistory.length} ‚Üí ${optimizedHistory.length} messages`);
    }

    // Calculer l'utilisation m√©moire
    const memoryUsage = calculateMemoryUsage(optimizedHistory);
    console.log(`üìä Utilisation m√©moire: ${memoryUsage.estimatedKB}KB/${memoryUsage.limitKB}KB (${memoryUsage.usagePercent}%) - ${memoryUsage.messages} messages, ${memoryUsage.summaries} r√©sum√©s`);

    const { success, response, context } = await chatWithMemory(message, optimizedHistory, userId);
    
    if (!success) {
      throw new Error('Chat IA failed');
    }

    const totalTime = Date.now() - startTime;
    
    console.log(`‚úÖ Chat IA complet en ${totalTime}ms (Context: ${context.length} chars)`);
    
    res.json({
      status: 'success',
      response,
      metadata: {
        source: 'omely-chat',
        processingTime: totalTime,
        contextLength: context.length,
        memoryOptimized: true,
        maxMessages: MEMORY_CONFIG.maxMessagesPerUser,
        maxSummaries: MEMORY_CONFIG.maxSummariesPerUser,
        memoryUsage: memoryUsage,
        mvpConfig: {
          maxUsers: MEMORY_CONFIG.maxTotalUsers,
          storagePerUser: `${MEMORY_CONFIG.maxStoragePerUser / 1024}KB`,
          totalStorage: '500MB'
        }
      }
    });

  } catch (error) {
    console.error(`‚ùå Chat IA error: ${error.message}`);
    res.status(500).json({
      status: 'error',
      message: error.message || 'Chat IA failed',
      processingTime: Date.now() - startTime
    });
  }
});

// Health check - Ultra rapide pour Fly.io
app.get('/health', (req, res) => {
  // R√©ponse imm√©diate sans calculs lourds
  res.set('Cache-Control', 'no-cache');
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: 'v6.0-optimized'
  });
});

// Health check d√©taill√©
app.get('/health/detailed', (req, res) => {
  res.json({
    status: 'OMELY BACKEND ULTRA-RAPIDE OK',
    timestamp: new Date().toISOString(),
    version: 'v6.0',
    services: {
      pdf: true,
      audio: true,
      video: true,
      openai: !!process.env.OPENAI_API_KEY,
      whisper: !!process.env.OPENAI_API_KEY,
      chat: true,
        optimized: true
      },
    uptime: process.uptime()
  });
});

// PDF summarization
app.post('/summarize/pdf', upload.single('file'), async (req, res) => {
  const startTime = Date.now();
  
  try {
    if (!req.file) {
      return res.status(400).json({
        status: 'error',
        message: 'PDF file required',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üìÑ PDF summarization: ${req.file.originalname}`);

    // Lire le fichier PDF
    const pdfBuffer = await fs.readFile(req.file.path);
    
    // Nettoyer le fichier temp
    await fs.unlink(req.file.path);

    // 1. Extraire le texte du PDF
    const { success: extractSuccess, text, extractionTime } = await extractTextFromPDF(pdfBuffer);
    if (!extractSuccess) {
      throw new Error('PDF text extraction failed');
    }

    // 2. R√©sumer le contenu avec le titre du livre
    const bookTitle = req.file.originalname.replace(/\.pdf$/i, '').replace(/[-_]/g, ' ');
    const { success: summarySuccess, summary, summarizationTime } = await summarizeContent(text, 'pdf', { bookTitle });
    if (!summarySuccess) {
      throw new Error('Summarization failed');
    }

    const totalTime = Date.now() - startTime;
    
    console.log(`‚úÖ PDF summarization complet en ${totalTime}ms`);
    
    res.json({
      status: 'success',
      summary,
      metadata: {
        source: 'pdf',
        filename: req.file.originalname,
        extractionTime,
        summarizationTime,
        totalProcessingTime: totalTime,
        textLength: text.length,
        summaryLength: summary.length
      }
    });

  } catch (error) {
    console.error(`‚ùå PDF summarization error: ${error.message}`);
    console.error(`‚ùå Error stack: ${error.stack}`);

    // Log d√©taill√© pour debug
    console.error(`üìÑ PDF info: ${req.file.originalname} (${req.file.size} bytes)`);
    console.error(`üìä Extraction: ${extractSuccess ? 'SUCCESS' : 'FAILED'}`);
    if (extractSuccess) {
      console.error(`üìä Texte extrait: ${text ? text.length : 0} caract√®res`);
    }

    res.status(500).json({
      status: 'error',
      message: error.message || 'PDF summarization failed',
      details: {
        filename: req.file?.originalname,
        fileSize: req.file?.size,
        textLength: text?.length,
        extractionSuccess: extractSuccess,
        errorStack: error.stack
      },
      processingTime: Date.now() - startTime
    });
  }
});

// Audio summarization (MP3)
app.post('/summarize/audio', upload.single('file'), async (req, res) => {
  const startTime = Date.now();
  
  try {
    if (!req.file) {
      return res.status(400).json({
        status: 'error',
        message: 'Audio file required',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üéµ Audio summarization: ${req.file.originalname}`);

    // 1. Transcrire avec Whisper (utilisation directe du fichier pour √©conomiser m√©moire)
    const { success: transcribeSuccess, transcript, transcriptionTime } = await transcribeAudio(req.file.path);
    if (!transcribeSuccess) {
      throw new Error('Transcription failed');
    }

    // 2. R√©sumer le contenu
    const { success: summarySuccess, summary, summarizationTime } = await summarizeContent(transcript, 'audio');
    if (!summarySuccess) {
      throw new Error('Summarization failed');
    }

    const totalTime = Date.now() - startTime;
    
    console.log(`‚úÖ Audio summarization complet en ${totalTime}ms`);
    
    res.json({
      status: 'success',
      summary,
      metadata: {
        source: 'audio',
        filename: req.file.originalname,
        transcriptionTime,
        summarizationTime,
        totalProcessingTime: totalTime,
        transcriptLength: transcript.length,
        summaryLength: summary.length
      }
    });

  } catch (error) {
    console.error(`‚ùå Audio summarization error: ${error.message}`);
    res.status(500).json({
      status: 'error',
      message: error.message || 'Audio summarization failed',
      processingTime: Date.now() - startTime
    });
  }
});

// Video summarization (MP4)
app.post('/summarize/video', upload.single('file'), async (req, res) => {
  const startTime = Date.now();
  
  try {
    if (!req.file) {
      return res.status(400).json({
        status: 'error',
        message: 'Video file required',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üé¨ Video summarization: ${req.file.originalname}`);

    // Lire le fichier vid√©o
    const videoBuffer = await fs.readFile(req.file.path);
    
    // Nettoyer le fichier temp
    await fs.unlink(req.file.path);

    // 1. Extraire l'audio depuis la vid√©o
    const { success: extractSuccess, audioFilePath, extractionTime } = await extractAudioFromMP4(videoBuffer);
    if (!extractSuccess) {
      throw new Error('Audio extraction failed');
    }

    // 2. Transcrire avec Whisper (utilisation directe du fichier audio pour √©conomiser m√©moire)
    const { success: transcribeSuccess, transcript, transcriptionTime } = await transcribeAudio(audioFilePath);
    if (!transcribeSuccess) {
      throw new Error('Transcription failed');
    }

    // 3. R√©sumer le contenu
    const { success: summarySuccess, summary, summarizationTime } = await summarizeContent(transcript, 'video');
    if (!summarySuccess) {
      throw new Error('Summarization failed');
    }

    const totalTime = Date.now() - startTime;
    
    console.log(`‚úÖ Video summarization complet en ${totalTime}ms`);
    
    res.json({
      status: 'success',
      summary,
      metadata: {
        source: 'video',
        filename: req.file.originalname,
        extractionTime,
        transcriptionTime,
        summarizationTime,
        totalProcessingTime: totalTime,
        transcriptLength: transcript.length,
        summaryLength: summary.length
      }
    });

  } catch (error) {
    console.error(`‚ùå Video summarization error: ${error.message}`);
    res.status(500).json({
      status: 'error',
      message: error.message || 'Video summarization failed',
      processingTime: Date.now() - startTime
    });
  }
});

// ENDPOINT EXTRACTION COMPL√àTE DE LIVRE (/extract/book) - PERMANENT
app.post('/extract/book', upload.single('file'), async (req, res) => {
  const startTime = Date.now();
  
  try {
    if (!req.file) {
      return res.status(400).json({
        status: 'error',
        message: 'PDF file required for book extraction',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üìö EXTRACTION COMPL√àTE DE LIVRE: ${req.file.originalname}`);

    // Lire le fichier PDF
    const pdfBuffer = await fs.readFile(req.file.path);
    
    // Nettoyer le fichier temp
    await fs.unlink(req.file.path);

    // 1. Extraire le texte du PDF
    const { success: extractSuccess, text, extractionTime, pages } = await extractTextFromPDF(pdfBuffer);
    if (!extractSuccess) {
      throw new Error('PDF text extraction failed');
    }

    console.log(`üìÑ Texte extrait: ${text.length} caract√®res, ${pages} pages`);

    // 2. D√©terminer la m√©thode d'extraction selon la taille
    let summary, metadata;
    
    // Migration vers GPT-4o mini V2 pour tous les livres
    console.log(`üìö Extraction livre avec GPT-4o mini V2 (${text.length} caract√®res)`);
    
    const bookTitle = req.file.originalname.replace('.pdf', '');
    
    // Utiliser le nouveau service GPT-4o mini
    const result = await extractCompleteBookContent(text, bookTitle);
    
    if (!result.success) {
      throw new Error(`Extraction GPT-4o mini √©chou√©e: ${result.error}`);
    }
    
    summary = result.completeSummary;
    metadata = {
      source: 'book-extraction-gpt4o',
      filename: req.file.originalname,
      extractionMethod: 'GPT4O_MINI',
      originalTextLength: text.length,
      pages,
      extractionTime,
      bookProcessingTime: result.metadata.totalProcessingTime,
      totalProcessingTime: Date.now() - startTime,
      quality: 'PROFESSIONAL_GRADE',
      provider: 'GPT-4o mini',
      model: 'gpt-4o-mini'
    };

    console.log(`‚úÖ EXTRACTION COMPL√àTE DE LIVRE r√©ussie en ${Date.now() - startTime}ms`);
    
    res.json({
      status: 'success',
      summary: summary,
      metadata: metadata,
      extractionNote: "‚úÖ EXTRACTION COMPL√àTE - Ce r√©sum√© capture 100% de la valeur du livre avec une pr√©cision professionnelle. Tous les principes d'enrichissement ont √©t√© extraits.",
      chatIntegration: {
        forChat: true,
        preserveInHistory: true,
        messageType: 'document_summary'
      }
    });

  } catch (error) {
    console.error(`‚ùå Book extraction error: ${error.message}`);
    
    if (req.file) {
      await fs.unlink(req.file.path).catch(() => {});
    }
    
    res.status(500).json({
      status: 'error',
      message: error.message || 'Book extraction failed',
      processingTime: Date.now() - startTime
    });
  }
});

// ENDPOINT CHAT AVEC INT√âGRATION R√âSUM√âS (/chat-with-summary)
app.post('/chat-with-summary', async (req, res) => {
  const startTime = Date.now();
  
  try {
    const { 
      message, 
      conversationHistory = [], 
      userId = null,
      summaryContent = null,
      summaryMetadata = null
    } = req.body;
    
    if (!message && !summaryContent) {
      return res.status(400).json({
        status: 'error',
        message: 'Message or summary content required',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üí¨ Chat avec int√©gration r√©sum√© demand√©`);

    // Si c'est un r√©sum√©, l'int√©grer dans l'historique de mani√®re persistante
    let enhancedHistory = [...conversationHistory];
    let finalMessage = message;
    
    if (summaryContent) {
      // Cr√©er un message assistant avec le r√©sum√©
      const summaryMessage = {
        role: 'assistant',
        content: summaryContent,
        timestamp: new Date().toISOString(),
        metadata: {
          type: 'document_summary',
          ...summaryMetadata
        }
      };
      
      enhancedHistory.push(summaryMessage);
      
      // Si pas de message utilisateur, cr√©er un message g√©n√©rique
      if (!message) {
        finalMessage = `Voici le r√©sum√© du document "${summaryMetadata?.filename || 'document'}". Peux-tu m'aider √† analyser ce contenu ?`;
      }
    }

    // Optimisation m√©moire: Limiter l'historique
    const optimizedHistory = enhancedHistory.slice(-MEMORY_CONFIG.maxMessagesPerUser);
    
    if (enhancedHistory.length > MEMORY_CONFIG.maxMessagesPerUser) {
      console.log(`üìä Historique optimis√©: ${enhancedHistory.length} ‚Üí ${optimizedHistory.length} messages`);
    }

    // Calculer l'utilisation m√©moire
    const memoryUsage = calculateMemoryUsage(optimizedHistory);
    console.log(`üìä Utilisation m√©moire: ${memoryUsage.estimatedKB}KB/${memoryUsage.limitKB}KB (${memoryUsage.usagePercent}%) - ${memoryUsage.messages} messages, ${memoryUsage.summaries} r√©sum√©s`);

    // Appeler le chat avec m√©moire
    const { success, response, context } = await chatWithMemory(finalMessage, optimizedHistory, userId);
    
    if (!success) {
      throw new Error('Chat IA failed');
    }

    const totalTime = Date.now() - startTime;
    
    console.log(`‚úÖ Chat avec r√©sum√© complet en ${totalTime}ms`);
    
    res.json({
      status: 'success',
      response,
      summaryIntegrated: !!summaryContent,
      metadata: {
        source: 'omely-chat-with-summary',
        processingTime: totalTime,
        contextLength: context.length,
        memoryOptimized: true,
        summaryPreserved: !!summaryContent,
        memoryUsage: memoryUsage
      }
    });

  } catch (error) {
    console.error(`‚ùå Chat avec r√©sum√© error: ${error.message}`);
    res.status(500).json({
      status: 'error',
      message: error.message || 'Chat avec r√©sum√© failed',
      processingTime: Date.now() - startTime
    });
  }
});

// Test route
app.get('/test', (req, res) => {
  res.json({
    message: 'OMELY Backend EXTRACTION COMPL√àTE v6.4 fonctionne !',
    timestamp: new Date().toISOString(),
    features: {
      'extraction_complete': true,
      'chunks_system_fixed': true,
      'visual_formatting': true,
      'professional_layout': true,
      'retry_system': true,
      'no_limited_extract_message': true,
      'markdown_tables': true,
      'numbered_action_plans': true,
      'visual_separators': true,
      'chat_persistence': true,
      'summary_preservation': true,
      'metadata_storage': true
    },
    formatting: {
      'visual_separators': '‚ïê‚ïê‚ïê and ---',
      'comparison_tables': 'Riches vs Pauvres',
      'numbered_principles': '1. 2. 3. format',
      'formatted_quotes': '> üåü *"quote"*',
      'emoji_categories': 'üîë üí∞ ‚ö° üéØ',
      'markdown_styling': '**bold** and *italic*'
    },
    endpoints: {
      'book_extraction': '/extract/book',
      'pdf_standard': '/summarize/pdf',
      'audio': '/summarize/audio',
      'video': '/summarize/video',
      'chat': '/chat',
      'chat_with_summary': '/chat-with-summary',
      'health': '/health'
    },
    persistence: {
      'summary_storage': 'Supabase integration',
      'chat_memory': 'Conversation history preserved',
      'metadata_tracking': 'Full document metadata saved'
    },
    version: '6.4',
    optimization: {
      'max_text_length': OPTIMIZATION_CONFIG.maxTextLength,
      'chunk_size': OPTIMIZATION_CONFIG.chunkSize,
      'timeout_ms': OPTIMIZATION_CONFIG.timeoutMs
    }
  });
});

// FONCTION G√âN√âRATION QUIZ ULTRA-RAPIDE AVEC GPT-4o mini
async function generateQuizFromSummary(summaryContent, options = {}) {
  const startTime = Date.now();

  try {
    console.log('‚ö° G√©n√©ration ultra-rapide de quiz avec GPT-4o mini...');

    // PROMPT ULTRA-COURT ET OPTIMIS√â POUR LA VITESSE
    const quizPrompt = `Cr√©ez un quiz de 5 questions bas√© sur ce r√©sum√©. Format JSON strict:

CONTENU:
${summaryContent.substring(0, 2000)}...

R√àGLES:
- 5 questions QCM seulement (A,B,C,D)
- Questions bas√©es sur le contenu
- 1 bonne r√©ponse par question
- Explication courte pour chaque r√©ponse
- Difficult√©: facile/moyen/difficile

FORMAT JSON:
{
  "title": "Titre du quiz",
  "description": "Description courte",
  "questions": [
    {
      "id": 1,
      "question": "Question?",
      "options": {"A": "Option A", "B": "Option B", "C": "Option C", "D": "Option D"},
      "correctAnswer": "A",
      "explanation": "Explication courte",
      "difficulty": "facile"
    }
  ]
}

QUIZ JSON:`;

    // APPEL ULTRA-RAPIDE AVEC PARAM√àTRES OPTIMIS√âS
    const messages = [
      { role: 'system', content: 'G√©n√©rez un quiz JSON rapidement.' },
      { role: 'user', content: quizPrompt }
    ];

    const quizResponse = await createChatCompletion(messages, {
      max_tokens: 1500,  // R√âDUIT de 4000 √† 1500 tokens
      temperature: 0.3,  // R√âDUIT de 0.7 √† 0.3 pour plus de rapidit√©
      model: 'gpt-4o-mini'
    });

    console.log('‚úÖ Quiz g√©n√©r√© par GPT-4o mini');

    // Parser la r√©ponse JSON
    let quizData;
    try {
      // Nettoyer la r√©ponse pour extraire le JSON
      const jsonMatch = quizResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        quizData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('Format JSON non trouv√© dans la r√©ponse');
      }
    } catch (parseError) {
      console.error('‚ùå Erreur parsing JSON du quiz:', parseError);
      // Fallback: cr√©er un quiz simple en cas d'erreur de parsing
      quizData = {
        title: "Quiz - Probl√®me de g√©n√©ration",
        description: "Quiz de secours g√©n√©r√© automatiquement",
        questions: [{
          id: 1,
          question: "Quel est l'objectif principal des principes d'enrichissement?",
          options: {
            A: "Accumuler de la richesse rapidement",
            B: "D√©velopper une mentalit√© d'abondance",
            C: "Investir dans des actions uniquement",
            D: "√âconomiser le plus possible"
          },
          correctAnswer: "B",
          explanation: "Les principes d'enrichissement visent principalement √† d√©velopper une mentalit√© d'abondance et des habitudes financi√®res saines.",
          difficulty: "facile",
          topic: "Mentalit√© d'enrichissement"
        }]
      };
    }

    // Validation basique du quiz
    if (!quizData.questions || quizData.questions.length === 0) {
      throw new Error('Aucune question g√©n√©r√©e');
    }

    // Ajouter des m√©tadonn√©es
    quizData.metadata = {
      generatedBy: 'GPT-4o mini',
      generationTime: Date.now() - startTime,
      sourceContent: summaryContent.substring(0, 100) + '...',
      questionCount: quizData.questions.length,
      provider: 'GPT-4o mini',
      model: 'gpt-4o-mini'
    };

    console.log(`‚úÖ Quiz g√©n√©r√©: ${quizData.questions.length} questions en ${Date.now() - startTime}ms`);

    return {
      success: true,
      quiz: quizData,
      processingTime: Date.now() - startTime
    };

  } catch (error) {
    console.error('‚ùå Erreur g√©n√©ration quiz:', error);

    return {
      success: false,
      error: error.message,
      processingTime: Date.now() - startTime
    };
  }
}

// QUIZ ENDPOINT AVEC DEEPSEEK V2
app.post('/api/generate-quiz', async (req, res) => {
  const startTime = Date.now();

  try {
    console.log('üß† G√©n√©ration de quiz avec GPT-4o mini V2...');

    const { summaryContent, options = {} } = req.body;

    if (!summaryContent || typeof summaryContent !== 'string' || summaryContent.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Contenu de r√©sum√© manquant ou invalide. Fournissez un r√©sum√© valide pour g√©n√©rer le quiz.',
        processingTime: Date.now() - startTime
      });
    }

    // V√©rifier la longueur minimale du contenu
    if (summaryContent.length < 100) {
      return res.status(400).json({
        success: false,
        error: 'Le r√©sum√© est trop court pour g√©n√©rer un quiz de qualit√©. Minimum 100 caract√®res requis.',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üìä G√©n√©ration de quiz pour ${summaryContent.length} caract√®res de contenu`);

    // G√©n√©rer le quiz avec GPT-4o mini
    const result = await generateQuizFromSummary(summaryContent, options);

    if (!result.success) {
      return res.status(500).json({
        success: false,
        error: `√âchec de la g√©n√©ration du quiz: ${result.error}`,
        processingTime: Date.now() - startTime
      });
    }

    // Validation finale
    if (!result.quiz || !result.quiz.questions || result.quiz.questions.length === 0) {
      return res.status(500).json({
        success: false,
        error: 'Quiz g√©n√©r√© invalide - aucune question cr√©√©e',
        processingTime: Date.now() - startTime
      });
    }

    const totalTime = Date.now() - startTime;
    console.log(`‚úÖ Quiz g√©n√©r√© avec succ√®s: ${result.quiz.questions.length} questions en ${totalTime}ms`);

    res.json({
      success: true,
      quiz: result.quiz,
      metadata: {
        source: 'openai-gpt4o-mini',
        processingTime: totalTime,
        contentLength: summaryContent.length,
        questionCount: result.quiz.questions.length,
        provider: 'GPT-4o mini',
        model: 'gpt-4o-mini',
        generatedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur endpoint quiz:', error);

    res.status(500).json({
      success: false,
      error: `Erreur interne lors de la g√©n√©ration du quiz: ${error.message}`,
      processingTime: Date.now() - startTime
    });
  }
});

// Endpoint pour g√©n√©rer le pr√©-test (2-3 questions g√©n√©rales)
app.post('/api/generate-pretest', async (req, res) => {
  const startTime = Date.now();

  try {
    console.log('üß† G√©n√©ration de pr√©-test avec GPT-4o mini V2...');

    const { summaryContent, options = {} } = req.body;

    if (!summaryContent || typeof summaryContent !== 'string' || summaryContent.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Contenu de r√©sum√© manquant ou invalide. Fournissez un r√©sum√© valide pour g√©n√©rer le pr√©-test.',
        processingTime: Date.now() - startTime
      });
    }

    // V√©rifier la longueur minimale du contenu
    if (summaryContent.length < 50) {
      return res.status(400).json({
        success: false,
        error: 'Le r√©sum√© est trop court pour g√©n√©rer un pr√©-test. Minimum 50 caract√®res requis.',
        processingTime: Date.now() - startTime
      });
    }

    console.log(`üìä G√©n√©ration de pr√©-test pour ${summaryContent.length} caract√®res de contenu`);

    // G√©n√©rer le pr√©-test avec GPT-4o mini
    const result = await generatePreTestFromSummary(summaryContent, options);

    if (!result.success) {
      return res.status(500).json({
        success: false,
        error: `√âchec de la g√©n√©ration du pr√©-test: ${result.error}`,
        processingTime: Date.now() - startTime
      });
    }

    // Validation finale
    if (!result.pretest || !result.pretest.questions || result.pretest.questions.length === 0) {
      return res.status(500).json({
        success: false,
        error: 'Pr√©-test g√©n√©r√© invalide - aucune question cr√©√©e',
        processingTime: Date.now() - startTime
      });
    }

    const totalTime = Date.now() - startTime;
    console.log(`‚úÖ Pr√©-test g√©n√©r√© avec succ√®s: ${result.pretest.questions.length} questions en ${totalTime}ms`);

    res.json({
      success: true,
      pretest: result.pretest,
      metadata: {
        source: 'openai-gpt4o-mini',
        processingTime: totalTime,
        contentLength: summaryContent.length,
        questionCount: result.pretest.questions.length,
        provider: 'GPT-4o mini',
        model: 'gpt-4o-mini',
        generatedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur endpoint pr√©-test:', error);

    res.status(500).json({
      success: false,
      error: `Erreur interne lors de la g√©n√©ration du pr√©-test: ${error.message}`,
      processingTime: Date.now() - startTime
    });
  }
});

// Fonction pour g√©n√©rer le pr√©-test (questions g√©n√©rales seulement)
export async function generatePreTestFromSummary(summaryContent, options = {}) {
  const startTime = Date.now();

  try {
    console.log('‚ö° G√©n√©ration ultra-rapide de pr√©-test avec GPT-4o mini V2...');

    // PROMPT ULTRA-COURT ET OPTIMIS√â POUR LE PR√â-TEST
    const pretestPrompt = `Cr√©ez un pr√©-test de 2-3 questions g√©n√©rales bas√©es sur ce r√©sum√©. Format JSON strict:

CONTENU:
${summaryContent.substring(0, 1500)}...

R√àGLES:
- 2-3 questions QCM seulement (A,B,C,D)
- Questions G√âN√âRALES (pas trop sp√©cifiques)
- Questions pour √©valuer les connaissances de base
- 1 bonne r√©ponse par question
- Explication courte pour chaque r√©ponse
- Difficult√©: facile/moyen

FORMAT JSON:
{
  "title": "Que savez-vous d√©j√† ?",
  "description": "Testez vos connaissances avant de lire",
  "questions": [
    {
      "id": 1,
      "question": "Question g√©n√©rale sur le th√®me principal?",
      "options": {"A": "Option A", "B": "Option B", "C": "Option C", "D": "Option D"},
      "correctAnswer": "A",
      "explanation": "Explication courte",
      "difficulty": "facile"
    }
  ]
}

PR√â-TEST JSON:`;

    // APPEL ULTRA-RAPIDE AVEC PARAM√àTRES OPTIMIS√âS
    const messages = [
      { role: 'system', content: 'G√©n√©rez un pr√©-test JSON rapidement avec des questions g√©n√©rales.' },
      { role: 'user', content: pretestPrompt }
    ];

    const pretestResponse = await createChatCompletion(messages, {
      max_tokens: 800,  // Plus court que le quiz complet
      temperature: 0.4,  // L√©g√®rement plus cr√©atif que le quiz
      model: 'gpt-4o-mini'
    });

    console.log('‚úÖ Pr√©-test g√©n√©r√© par GPT-4o mini V2');

    // Parser la r√©ponse JSON
    let pretestData;
    try {
      // Nettoyer la r√©ponse pour extraire le JSON
      const jsonMatch = pretestResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        pretestData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('Format JSON non trouv√© dans la r√©ponse');
      }
    } catch (parseError) {
      console.error('‚ùå Erreur parsing JSON du pr√©-test:', parseError);
      // Fallback: cr√©er un pr√©-test simple en cas d'erreur de parsing
      pretestData = {
        title: "Que savez-vous d√©j√† ?",
        description: "Testez vos connaissances avant de lire",
        questions: [{
          id: 1,
          question: "Quel est le th√®me principal abord√© dans ce contenu?",
          options: {
            A: "D√©veloppement personnel",
            B: "Technologie avanc√©e",
            C: "Cuisine internationale",
            D: "Sports extr√™mes"
          },
          correctAnswer: "A",
          explanation: "Le contenu traite de th√®mes li√©s au d√©veloppement personnel et √† l'efficacit√©.",
          difficulty: "facile"
        }]
      };
    }

    // Validation basique du pr√©-test
    if (!pretestData.questions || pretestData.questions.length === 0) {
      throw new Error('Aucune question g√©n√©r√©e pour le pr√©-test');
    }

    // S'assurer qu'il y a au maximum 3 questions pour le pr√©-test
    if (pretestData.questions.length > 3) {
      pretestData.questions = pretestData.questions.slice(0, 3);
    }

    // Ajouter des m√©tadonn√©es
    pretestData.metadata = {
      generatedBy: 'GPT-4o mini',
      generationTime: Date.now() - startTime,
      sourceContent: summaryContent.substring(0, 100) + '...',
      questionCount: pretestData.questions.length,
      provider: 'GPT-4o mini',
      model: 'gpt-4o-mini',
      type: 'pretest'
    };

    console.log(`‚úÖ Pr√©-test g√©n√©r√©: ${pretestData.questions.length} questions en ${Date.now() - startTime}ms`);

    return {
      success: true,
      pretest: pretestData
    };

  } catch (error) {
    console.error('‚ùå Erreur g√©n√©ration pr√©-test:', error);
    return {
      success: false,
      error: error.message,
      pretest: null
    };
  }
}

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('‚ùå Unhandled error:', error);
  res.status(500).json({
    status: 'error',
    message: 'Internal server error',
    error: error.message
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    status: 'error',
    message: 'Route not found'
  });
});

const PORT = process.env.PORT || 3002;
const HOST = process.env.HOST || '0.0.0.0';

// Chargement des services puis d√©marrage du serveur
async function startServer() {
  console.log('üîß Chargement des services avant d√©marrage...');

  // Charger les services en premier
  await loadServices();

  console.log('üöÄ D√©marrage du serveur...');

  // D√©marrage du serveur seulement apr√®s chargement des services
  const server = app.listen(PORT, HOST, () => {
    console.log(`üöÄ OMELY Backend v6.0-stable d√©marr√© sur ${HOST}:${PORT}`);
    console.log(`üîó Health check: http://localhost:${PORT}/health`);
    console.log(`üß™ Test: http://localhost:${PORT}/test`);
    console.log(`ü§ñ V√©rification GPT-4o mini: http://localhost:${PORT}/verify-gpt4o`);
    console.log(`üí¨ Chat IA: POST http://localhost:${PORT}/chat`);
    console.log(`üìö EXTRACTION COMPL√àTE DE LIVRE: POST http://localhost:${PORT}/extract/book`);
    console.log(`üìÑ PDF Standard: POST http://localhost:${PORT}/summarize/pdf`);
    console.log(`üéµ Audio: POST http://localhost:${PORT}/summarize/audio`);
    console.log(`üé¨ Video: POST http://localhost:${PORT}/summarize/video`);
    console.log(`üß† QUIZ ROUTE: POST http://localhost:${PORT}/api/generate-quiz`);
    console.log(`üîß Services charg√©s: ${servicesLoaded ? '‚úÖ' : '‚ùå'}`);
    console.log(`ü§ñ GPT-4o mini disponible: ${services.openai ? '‚úÖ' : '‚ùå'}`);
  });

  // Gestion des erreurs du serveur
  server.on('error', (error) => {
    console.error('‚ùå Erreur du serveur:', error);
  });

  // Gestion de l'arr√™t propre
  process.on('SIGTERM', () => {
    console.log('üõë Signal SIGTERM re√ßu, arr√™t propre...');
    server.close(() => {
      console.log('‚úÖ Serveur arr√™t√© proprement');
      process.exit(0);
    });
  });

  process.on('SIGINT', () => {
    console.log('üõë Signal SIGINT re√ßu, arr√™t propre...');
    server.close(() => {
      console.log('‚úÖ Serveur arr√™t√© proprement');
      process.exit(0);
    });
  });
}

// D√©marrage asynchrone du serveur
startServer().catch((error) => {
  console.error('‚ùå Erreur fatale lors du d√©marrage:', error);
  process.exit(1);
});

